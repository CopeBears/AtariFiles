<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Onslaught! Arena (dev)</title>
	<style>
/* 		@font-face {
			font-family: 'MedievalSharp';
			font-style: normal;
			font-weight: normal;
			src: local('MedievalSharp'), url('../font/MedievalSharp.ttf') format('woff');
		} */

		html {
			background: #000;
		}

		html, body {
			margin: 0;
			padding: 0;
		}

		.hidden {
			display: none;
		}

		#stage {
		position: relative;
		}

		canvas {
			border: solid 1px #231f20;
			background: #000;
			color: #f1f1f2;
		}

		.fallback {
			background: #000;
			color: #f1f1f2;
			font-family: Tahoma, Arial, Sans;
			text-align: center;
		}

		.fallback p {
			display: block;
		}

		.fallback a {
			color: #7c51a1;
			font-weight: bold;
		}

		.nav {
			border-bottom: solid 2px #3c3533;
			padding: 5px 10px;
			overflow: hidden;
			background: #636467;
			font-family: MedievalSharp, Tahoma, Arial;
			font-size: 24px;
		}

		.nav > ul {
		float: right;
			margin: 0;
			padding: 0;

			overflow: hidden;
		}

		.nav > ul li {
			float: left;
			list-style: none;
			margin-right: 30px;
		}

		.nav a {
			color: #f1f1f2;
			text-decoration: none;
			text-shadow: #000 1px 1px 1px;
			font-weight: bold;
		}

		.nav a:hover {
			color: #faa61a;
		}

		#tip {
			position: absolute;
			left: 0;
			top: 0;

			padding: 5px;

			color: #f1f1f2;
			font-family: Tahoma, Arial, Sans;
			font-size: 14px;
			font-weight: bold;
			text-align: center;
			text-shadow: #91661e 1px 1px 2px;
		}

		#tip_controls {
			cursor: pointer;
			float: right;
			padding-right: 5px;
		}

		#tip_controls.show {
			color: #f1f1f2;
		}

		#tip_controls.hide {
			color: #6d6e70;
			text-shadow: #000 1px 1px 2px;
		}

		.fade-in, .fade-out {
			-moz-transition: all 1s ease-in-out;
			-o-transition: all 1s ease-in-out;
			-webkit-transition: all 1s ease-in-out;
		}

		.fade-in {
			opacity: 1;
		}

		.fade-out {
			opacity: 0;
		}

		.full #tip {
			display: none;
		}

		#tip span {
			font-style: italic;
		}

		#tip a {
			color: #faa61a;
			text-decoration: underline;
		}

		#tip a:hover {
			text-decoration: none;
		}

		.ad.leaderboard {
			margin-top: 10px;
			text-align: center;
		}

		/* Clay.io style overrides */
		body #clay .clay-notification, body #clay .clay-modal-wrapper {
			border: 2px solid #cca204;
			padding: 0;
			font-family: MedievalSharp;
			background: rgba( 0, 0, 0, 0.8 );

			-webkit-box-shadow: none;
			-moz-box-shadow: none;
			box-shadow: none;
		}

		body #clay .clay-notification .clay-notification-content a {
			color: #fff;
		}

		#clay .clay-content {
			max-width: 446px;
		}

		body #clay .clay-modal, body #clay #clay-leaderboard-wrapper-inner {
			background: transparent;
		}

		body #clay .clay-notification .clay-notification-header {
			background: transparent;
			color: #cca204;
			font-size: 1.5em;
		}

		body #clay .clay-notification .clay-notification-content {
			background: transparent;
			color: #fff;
		}

		body #clay h2.clay-banner {
			background: transparent;
			text-align: center;
			color: #cca204;
		}

		body #clay h3.clay-powered-by {
			background: transparent;
			border-bottom: 1px solid #fff;
		}

		body #clay h2.clay-banner img {
			display: none;
		}

		body #clay table tbody tr td, body #clay table tbody tr th, body #clay table thead tr td, body #clay table thead tr th, body #clay table tbody tr.clay-leaderboard-me td, body #clay table tbody tr.clay-leaderboard-me th {
			color: #fff;
		}

		body #clay table tbody tr td a, body #clay table tbody tr.clay-leaderboard-me td a {
			color: #cca204;
		}

		body #clay #clay-achievements-wrapper-content .clay-achievement-single {
			color: #fff;
		}

		body #clay #clay-leaderboard-wrapper .clay-leaderboard-custom-html {
			color: #fff;
		}

		body #clay #clay-leaderboard-wrapper .clay-leaderboard-custom-html a {
			color: #cca204;
		}

		body #clay .close, #clay .clay-close, body #clay .clay-notification-close {
			background: none;
			color: white;
			text-decoration: none;
			font-size: 3em;
			top: 0;
		}
		body #clay .clay-notification-close {
			font-size: 1.5em;
			top: 0;
			right: 3px;
		}

	</style>
</head>
<body>

	<div id="stage" height="500px" width="500px"></div>


	<script>
		/**
		 * horde - A quick game
		 * @var object
		 */
		var horde = {};

		horde.canvasFallbackContent = "<div class=\"fallback\"><p>Your browser does not appear to support <a href=\"http://en.wikipedia.org/wiki/HTML5\">HTML5</a>.</p><p>Please try one of the following, more standards compliant browsers: <a href=\"http://www.google.com/chrome\">Chrome</a>, <a href=\"http://www.apple.com/safari/\">Safari</a>, <a href=\"http://www.mozilla.com/firefox/\">Firefox</a> or <a href=\"http://www.opera.com/\">Opera</a>.</p></div>";

		// Bind a function to a particular context
		var bind = function (context, fn) {
			if (typeof fn == "string") {
				fn = context[fn];
			}
			return function () {
				fn.apply(context, arguments);
			};
		};

		// requestAnimationFrame shim
		if (typeof requestAnimationFrame == "undefined") {
			var requestAnimationFrame = (
				window.mozRequestAnimationFrame ||
				window.msRequestAnimationFrame ||
				window.oRequestAnimationFrame ||
				window.webkitRequestAnimationFrame ||
				function (callback) {
					setTimeout(function () {
						callback(Date.now());
					}, 17); // ~60 FPS
				}
			);
		}

		/**
		 * Context corrected window.setInterval() wrapper
		 * @param {number} when Milliseconds between intervals
		 * @param {object} fn Function to call each interval
		 * @param {object} context Value of "this" when calling function
		 * @return {number} Interval ID
		 */
		horde.setInterval = function horde_setInterval (when, fn, context) {
			var f = function horde_setInterval_anon () {
				fn.call(context);
			};
			return window.setInterval(f, when);
		};

		/**
		 * Context corrected window.setTimeout() wrapper
		 * @param {number} when Milliseconds before calling fn
		 * @param {object} fn Function to call
		 * @param {object} context Value of "this" when calling fn
		 * @return {number} Timeout ID
		 */
		horde.setTimeout = function horde_setTimeout (when, fn, context) {
			var f = function horde_setTimeout_anon () {
				fn.call(context);
			};
			return window.setTimeout(f, when);
		};

		/**
		 * Context corrected .addEventListener() wrapper
		 * @param {string} type Type of event
		 * @param {object} fn Function to call
		 * @param {object} target Object on which to listen
		 * @param {object} context Value of "this" when calling function
		 * @return {void}
		 */
		horde.on = function horde_on (type, fn, target, context) {
			target.addEventListener(type, function horde_on_anon (e) {
				fn.call(context, e);
			}, false);
		};

		/**
		 * Stops an event
		 * @param {object} e Event
		 * @return {void}
		 */
		horde.stopEvent = function horde_stopEvent (e) {
			e.cancelBubble = true;
			e.stopPropagation();
			e.preventDefault();
		};

		/**
		 * Returns the current UNIX time
		 * @return {number} Millisecodns since epoch
		 */
		horde.now = function horde_now () {
			return Date.now();
		};

		/**
		 * Creates a canvas elements and adds it to the document
		 * @param {string} id Element ID attribute
		 * @param {number} width Width of the canvas in pixels
		 * @param {number} height Height of the canvas in pixels
		 * @param {boolean} hidden Whether or not this canvas is visible
		 * @return {object} <canvas> element
		 */
		horde.makeCanvas = function horde_makeCanvas (id, width, height, hidden) {
			var canvas = document.createElement("canvas");
			canvas.id = id;
			canvas.width = Number(width) || 0;
			canvas.height = Number(height) || 0;
			if (hidden !== true) {
				canvas.innerHTML = horde.canvasFallbackContent;
				var stage = document.getElementById("stage");
				stage.appendChild(canvas);
			}
			return canvas;
		};

		/**
		 * Returns the x,y offset of an element on the page
		 * @param {DOMElement} node DOM Element
		 * @return {object} x,y offset
		 */
		horde.getOffset = function horde_getOffset (node) {
			var offset = {
				x: node.offsetLeft, y: node.offsetTop
			};
			while (true) {
				node = node.parentNode;
				if (node === document.body) {
					break;
				}
				offset.x += node.offsetLeft;
				offset.y += node.offsetTop;
			}

			scrollTop = horde.getScrollTop();
			offset.x -= scrollTop.x;
			offset.y -= scrollTop.y;

			return offset;
		};


		/**
		 * Returns object of the number of pixels the window is scrolled
		 * in both the x and y directions with top left as 0,0
		 * @return {object} Object containing "x" : scrollLeft and "y" : scrollTop
		 */
		horde.getScrollTop = function horde_getScrollTop() {
			if (typeof pageYOffset !== 'undefined') {
				//most browsers
				return { x: pageXOffset, y: pageYOffset };
			}
			else {
				var B = document.body; //IE 'quirks'
				var D = document.documentElement; //IE with doctype
				D = (D.clientHeight) ? D : B;
				return { x: D.scrollLeft, y: D.scrollTop };
			}
		}

		/**
		 * Returns a random number between min and max
		 * @param {number} min Minimum number
		 * @param {number} max Maximum number
		 * @return {number} Random number between min and max
		 */
		horde.randomRange = function horde_randomRange (min, max) {
			return (Math.round(Math.random() * (max - min)) + min);
		};

		horde.clamp = function horde_clamp (value, min, max) {
			return Math.min(Math.max(value, min), max);
		};

		/**
		 * Returns a randomly generated direction
		 * @return {horde.Vector2} Direction vector
		 */
		horde.randomDirection = function horde_randomDirection () {
			var d = new horde.Vector2(
				horde.randomRange(-10, 10),
				horde.randomRange(-10, 10)
			);
			d.normalize();
			return d;
		};

		/**
		 * Creates an object of a given type
		 * @param {string} type Object Type (maps to object_types.js)
		 * @param {boolean} supressInit Supress the init for this object?
		 * @return {object} New game object
		 */
		horde.makeObject = function horde_makeObject (type, supressInit) {
			var obj = new horde.Object();
			obj.type = type;
			for (var x in horde.objectTypes[type]) {
				obj[x] = horde.objectTypes[type][x];
			}
			if (supressInit !== true) {
				obj.init();
			}
			return obj;
		};

		/**
		 * Directions enumeration
		 */
		horde.directions = {
			UP: 0,
			UP_RIGHT: 1,
			RIGHT: 2,
			DOWN_RIGHT: 3,
			DOWN: 4,
			DOWN_LEFT: 5,
			LEFT: 6,
			UP_LEFT: 7,
			toVector: function (d) {
				if (d < 0) d += 8; // Fix for -1 should be UP_LEFT.
				if (d > 7) d -= 8; // Fix for -1 should be UP_LEFT.
				switch (d) {
					case horde.directions.UP:
						return new horde.Vector2(0, -1);
						break;
					case horde.directions.UP_RIGHT:
						return new horde.Vector2(1, -1);
						break;
					case horde.directions.RIGHT:
						return new horde.Vector2(1, 0);
						break;
					case horde.directions.DOWN_RIGHT:
						return new horde.Vector2(1, 1);
						break;
					case horde.directions.DOWN:
						return new horde.Vector2(0, 1);
						break;
					case horde.directions.DOWN_LEFT:
						return new horde.Vector2(-1, 1);
						break;
					case horde.directions.LEFT:
						return new horde.Vector2(-1, 0);
						break;
					case horde.directions.UP_LEFT:
						return new horde.Vector2(-1, -1);
						break;
				}
			},
			fromVector: function (v) {
				if (v.x > -0.25 && v.x < 0.25 && v.y < 0) {
					return horde.directions.UP;
				}
				if (v.x > -0.25 && v.x < 0.25 && v.y > 0) {
					return horde.directions.DOWN;
				}
				if (v.x > 0 && v.y > -0.25 && v.y < 0.25) {
					return horde.directions.RIGHT;
				}
				if (v.x < 0 && v.y > -0.25 && v.y < 0.25) {
					return horde.directions.LEFT;
				}
				if (v.x > 0 && v.y < 0) {
					return horde.directions.UP_RIGHT;
				}
				if (v.x > 0 && v.y > 0) {
					return horde.directions.DOWN_RIGHT;
				}
				if (v.x < 0 && v.y > 0) {
					return horde.directions.DOWN_LEFT;
				}
				if (v.x < 0 && v.y < 0) {
					return horde.directions.UP_LEFT;
				}
			}
		};

		horde.x = function (s, p) {
			var k = 0;
			var r = "";
			for (var y = 0; y < p.length; ++y) {
				k += p.charCodeAt(y);
			}
			for (var x = 0; x < s.length; ++x) {
				r += String.fromCharCode(k ^ s.charCodeAt(x));
			}
			return r;
		};

		(function define_logger () {

			var log = [];

			horde.log = function horde_log (info) {
				log.push(info);
				console.log(info);
			};

		}());

		(function define_horde_Timer () {

			/**
			 * General purpose timer
			 * @constructor
			 */
			horde.Timer = function horde_Timer () {
				this.elapsed_ms = 0;
				this.ttl = 0;
			};

			var Timer = horde.Timer;
			var proto = Timer.prototype;

			/**
			 * Returns the current time
			 * @return {number} Milliseconds since epoch
			 */
			Timer.now = function horde_Timer_now () {
				return Date.now();
			};

			/**
			 * Starts the timer
			 * @param {number} ttl Time to live
			 * @return {void}
			 */
			proto.start = function horde_Timer_proto_start (ttl) {
				if (ttl) {
					this.ttl = Number(ttl);
				}
				this.elapsed_ms = 0;
			};

			/**
			 * Updates the elapsed time of this timer
			 * @param {number} elapsed Elapsed milliseconds
			 * @return {void}
			 */
			proto.update = function horde_Timer_proto_update (elapsed) {
				this.elapsed_ms += elapsed;
			};

			/**
			 * Resets the timer's start time to now (same as calling start())
			 * @return {void}
			 */
			proto.reset = function horde_Timer_proto_reset () {
				this.start();
			};

			/**
			 * Returns the elapsed time since start (in milliseconds)
			 * @return {number} Elapsed time since start (in milliseconds)
			 */
			proto.elapsed = function horde_Timer_proto_elapsed () {
				return this.elapsed_ms;
			};

			/**
			 * Returns if this timer is expired or not based on it's TTL
			 * @return {boolean} True if elapsed > ttl otherwise false
			 */
			proto.expired = function horde_Timer_proto_expired () {
				if (this.ttl > 0) {
					return this.elapsed_ms > this.ttl;
				}
				return false;
			};

			}());

		(function define_horde_sound () {

		horde.sound = {};

		var api = "html5";
		var format = ".mp3";
		var muted = false;
		var sounds = {};
		var disabled = false;

		horde.sound.init = function horde_sound_init (callback) {

			if (typeof(Audio) == "undefined") {
				disabled = true;
				return;
			} else {
				disabled = false;
			}

			switch (api) {
				case "ios":
					callback();
					break;
				case "sm2":
					soundManager.useFastPolling = true;
					soundManager.useHighPerformance = true;
					soundManager.autoLoad = true;
					soundManager.multiShot = true;
					soundManager.volume = 100;
					soundManager.onload = callback;
					soundManager.useHTML5Audio = false;

					soundManager.onerror = (function (init) {
						return function () {
							api = "html5";
							init(callback);
						};
					}(arguments.callee));
					break;
				case "html5":
					var audio = document.createElement("audio");

					if (audio.canPlayType) {
						//audio.canPlayType('audio/ogg; codecs="vorbis"');
						if (!audio.canPlayType("audio/mpeg;")) {
							//format = ".ogg";
							api = null;
						}
					}

					callback();
					break;
			}
		};

		horde.sound.create = function horde_sound_create (id, url, loops, volume) {

			if (disabled) return;

			loops = Boolean(loops);
			url += format;

			if (volume === undefined) {
				volume = 100;
			}

			switch (api) {
				case "sm2":
					var params = {
						id: id,
						url: url,
						volume: volume
					};
					if (loops) {
						params.onfinish = function () {
							this.play();
						};
					}
					var sound = soundManager.createSound(params);
					sound.load();
					break;
				case "html5":
					var audio = new Audio();
					audio.preload = "auto";
					audio.src = url;
					if (loops) {
						audio.addEventListener("ended", function () {
							this.currentTime = 0;
							this.play();
						}, false);
					} else {
						audio.addEventListener("ended", function () {
							this.pause();
							this.currentTime = 0;
						}, false);
					}
					audio.load();
					audio.volume = volume / 100;
					sounds[id] = audio;
					break;
			}
		};

		horde.sound.isPlaying = function (id) {
			if (disabled) return;
			switch (api) {
				case "sm2":
					var sound = soundManager.getSoundById(id);
					if (sound) {
						return (sound.playState === 1);
					}
					return false;
				case "html5":
					return (sounds[id].currentTime > 0);
			}
		};

		horde.sound.play = function horde_sound_play (id) {
			if (disabled) return;
			if (muted) {
				return false;
			}
			switch (api) {
				case "ios":
					//location.href = ("jsbridge://play/" + id);
					location.href = ("jsbridge://" + id);
					break;
				case "sm2":
					soundManager.play(id);
					break;
				case "html5":
					try {
						sounds[id].pause();
						sounds[id].currentTime = 0;
						sounds[id].play();
					} catch (e) {}
					break;
			}
		};

		horde.sound.stop = function horde_sound_stop (id) {
			if (disabled) return;
			switch (api) {
				case "ios":
					//location.href = ("jsbridge://stop/" + id);
					break;
				case "sm2":
					soundManager.stop(id);
					break;
				case "html5":
					sounds[id].pause();
					sounds[id].currentTime = 0;
					break;
			}
		};

		horde.sound.stopAll = function horde_sound_stopAll () {
			if (disabled) return;
			switch (api) {
				case "ios":
					//location.href = ("jsbridge://stopAll");
					break;
				case "sm2":
					soundManager.stopAll();
					break;
				case "html5":
					try {
						for (var id in sounds) {
							sounds[id].pause();
							sounds[id].currentTime = 0;
						}
					} catch (e) {
						console.log("[ERROR horde.sound.stopAll]", e);
					}
					break;
			}
		};

		horde.sound.pauseAll = function horde_sound_pauseAll () {
			if (disabled) return;
			switch (api) {
				case "sm2":
					soundManager.pauseAll();
					break;
				case "html5":
					for (var id in sounds) {
						if (sounds[id].currentTime > 0) {
							sounds[id].pause();
						}
					}
					break;
			}
		};

		horde.sound.resumeAll = function horde_sound_resumeAll () {
			if (disabled) return;
			switch (api) {
				case "sm2":
					soundManager.resumeAll();
					break;
				case "html5":
					for (var id in sounds) {
						if (sounds[id].currentTime > 0) {
							sounds[id].play();
						}
					}
					break;
			}
		};

		horde.sound.toggleMuted = function horde_sound_toggleMuted () {
			horde.sound.setMuted(!horde.sound.isMuted());
		};

		horde.sound.isMuted = function horde_sound_isMuted () {
			return muted;
		};

		horde.sound.setMuted = function horde_sound_setMuted (muteSound) {
			if (muted === muteSound) {
				return;
			}
			muted = muteSound;
			if (muted) {
				horde.sound.pauseAll();
			} else {
				horde.sound.resumeAll();
			}
		};

		}());

		(function define_horde_Size () {

			/**
			 * Object for dealing with sizes
			 * @param {number} width Width
			 * @param {number} height Height
			 * @constructor
			 */
			horde.Size = function horde_Size (width, height) {
				this.width = Number(width) || 0;
				this.height = Number(height) || 0;
			};
				
			}());

		(function define_horde_Vector2 () {

		/**
		 * Object for dealing with 2D vectors
		 * @param {number} x X value
		 * @param {number} y Y value
		 * @constructor
		 */
		horde.Vector2 = function horde_Vector2 (x, y) {
			this.x = Number(x) || 0;
			this.y = Number(y) || 0;
		};

		var Vector2 = horde.Vector2;
		var proto = Vector2.prototype;

		/**
		 * Creates a vector from a horde.Size object
		 * @param {horde.Size} size Size
		 * @return {horde.Vector2} Vector representation of a size
		 */
		Vector2.fromSize = function horde_Vector2_fromSize (size) {
			return new horde.Vector2(size.width, size.height);
		};

		/**
		 * Creates a vector from a heading (and optionaly a magnitude)
		 * @param {number} heading Heading in radians
		 * @param {number} mag Magnitude (Optional; Defaults to 1)
		 * @return {horde.Vector2}
		 */
		Vector2.fromHeading = function horde_Vector2_fromHeading (heading, mag) {
			mag = Number(mag) || 1;
			return new horde.Vector2(
				Math.sin(heading) * mag,
				-Math.cos(heading) * mag
			);
		};

		/**
		 * Clones this vector
		 * @return {horde.Vector2} A clone of this vector
		 */
		proto.clone = function horde_Vector2_proto_clone () {
			return new horde.Vector2(this.x, this.y);
		};

		/**
		 * Scales this vector by a number
		 * @param {number} n Number to scale this vector by
		 * @return {horde.Vector2} This vector scaled by n
		 */
		proto.scale = function horde_Vector2_proto_scale (n) {
			this.x *= n;
			this.y *= n;
			return this;
		};

		proto.add = function horde_Vector2_proto_add (b) {
			this.x += b.x;
			this.y += b.y;
			return this;
		};

		proto.subtract = function horde_Vector2_proto_subtract (b) {
			this.x -= b.x;
			this.y -= b.y;
			return this;
		};
			
		proto.zero = function horde_Vector2_proto_zero () {
			this.x = 0;
			this.y = 0;
			return this;
		};

		proto.invert = function horde_Vector2_proto_invert () {
			this.x *= -1;
			this.y *= -1;
			return this;
		};

		proto.magnitude = function horde_Vector2_proto_magnitude () {
			return Math.sqrt(this.x * this.x + this.y * this.y);
		};

		proto.normalize = function horde_Vector2_proto_normalize () {
			var mag = this.magnitude();
			if (mag === 0) {
				return this;
			} else {
				return this.scale(1 / mag);
			}
		};

		proto.toString = function horde_Vector2_proto_toString () {
			return this.x + ", " + this.y;
		};

		proto.floor = function horde_Vector2_proto_floor () {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			return this;
		};

		proto.abs = function horde_Vector2_proto_abs () {
			this.x = Math.abs(this.x);
			this.y = Math.abs(this.y);
			return this;
		};

		proto.angle = function horde_Vector2_proto_angle () {
			return this.heading() * (180 / Math.PI);
		};

		proto.heading = function horde_Vector2_proto_heading () {
			return Math.atan2(this.x, -this.y);
		};

		}());

		(function define_horde_Rect () {

			/**
			 * Object for dealing with rectangles
			 * @param {number} left Left coordinate of the rectangle
			 * @param {number} top Top coordinate of the rectangle
			 * @param {number} width Width of the rectangle
			 * @param {number} height Height of the rectangle
			 * @constructor
			 */
			horde.Rect = function horde_Rect (left, top, width, height) {
				this.left = Number(left) || 0;
				this.top = Number(top) || 0;
				this.width = Number(width) || 0;
				this.height = Number(height) || 0;
			};

			var Rect = horde.Rect;
			var proto = Rect.prototype;

			/**
			 * Checks for intersection of two rectangles
			 * @param {horde.Rect} a First rectangle
			 * @param {horde.Rect} b Second rectangle
			 * @return {boolean} True if a and b intersect otherwise false
			 */
			Rect.intersects = function horde_Rect_intersects (a, b) {
				return (
					a.left <= (b.left + b.width) && 
					b.left <= (a.left + a.width) &&
					a.top <= (b.top + b.height) &&
					b.top <= (a.top + a.height)
				);
			};

			/**
			 * Returns the center of the rectangle as a vector
			 * @return {horde.Vector2} Vector representing the center point of this rectangle
			 */
			proto.center = function horde_Rect_proto_center () {
				var sizev = new horde.Vector2(this.width, this.height);
				return new horde.Vector2(this.left, this.top).add(sizev.scale(0.5));
			};

			/**
			 * Checks for intersection of this rectangle and another
			 * @param {horde.Rect} rect Rectangle to check
			 * @return {boolean} True if rect intersects with this rectangle otherwise false
			 */
			proto.intersects = function horde_Rect_proto_intersects (rect) {
				return Rect.intersects(this, rect);
			};

			/**
			 * Reduces the size of this rect by a given amount
			 * @param {number} amount Amount to reduce on each side
			 * @return {void}
			 */
			proto.reduce = function horde_Rect_proto_reduce (amount) {
				this.left += amount;
				this.top += amount;
				this.width -= amount * 2;
				this.height -= amount * 2;
				return this;
			};

			}());


		(function () {

			horde.Keyboard = function () {
				this.history = [];
				this.keyStates = {};
				this.lastKeyStates = {};
				horde.on("keydown", this.handleKeyDown, window, this);
				horde.on("keyup", this.handleKeyUp, window, this);
			};

			var Keyboard = horde.Keyboard;
			var proto = Keyboard.prototype;

			var Keys = {
				ESCAPE: 27,
				ENTER: 13,
				SPACE: 32,
				LEFT: 37,
				UP: 38,
				RIGHT: 39,
				DOWN: 40,
				A: 65,
				B: 66,
				D: 68,
				E: 69,
				F: 70,
				G: 71,
				K: 75,
				L: 76,
				M: 77,
				O: 79,
				P: 80,
				Q: 81,
				R: 82,
				S: 83,
				T: 84,
				U: 85,
				W: 87,
				X: 88,
				Z: 90
			};
			Keyboard.Keys = Keys;

			Keyboard.konamiCode = [
				Keys.UP,
				Keys.UP,
				Keys.DOWN,
				Keys.DOWN,
				Keys.LEFT,
				Keys.RIGHT,
				Keys.LEFT,
				Keys.RIGHT,
				Keys.B,
				Keys.A
			];

			Keyboard.debugCode = [
				Keys.L,
				Keys.D,
				Keys.D,
				Keys.E,
				Keys.B,
				Keys.U,
				Keys.G
			];

			Keyboard.resetCode = [
				Keys.L,
				Keys.D,
				Keys.R,
				Keys.E,
				Keys.S,
				Keys.E,
				Keys.T
			];

			Keyboard.godModeCode = [
				Keys.L,
				Keys.D,
				Keys.D,
				Keys.Q,
				Keys.D
			];

			Keyboard.allWeaponsCode = [
				Keys.L,
				Keys.D,
				Keys.K,
				Keys.F,
				Keys.A
			];

			Keyboard.awesmCode = [
				Keys.A,
				Keys.W,
				Keys.E,
				Keys.S,
				Keys.M
			];

			Keyboard.bombCode = [
				Keys.L,
				Keys.D,
				Keys.B,
				Keys.O,
				Keys.M,
				Keys.B
			];

			Keyboard.cyclopsCode = [
				67, // C
				89, // Y
				67, // C
				Keys.L,
				Keys.O,
				Keys.P,
				Keys.S
			];

			Keyboard.html5Code = [
				72,
				84,
				77,
				76,
				53
			];

			Keyboard.meatboyCode = [
				Keys.M,
				Keys.E,
				Keys.A,
				Keys.T
			];

			proto.supressKeys = function (e) {
				switch (e.keyCode) {
					// Note: intentional fallthroughs.
					case Keys.ENTER:
					case Keys.LEFT:
					case Keys.UP:
					case Keys.RIGHT:
					case Keys.DOWN:
					case Keys.B:
					case Keys.A:
					case Keys.M:
					case Keys.Z:
					case Keys.X:
					case Keys.P:
					case Keys.SPACE:
					case Keys.W:
					case Keys.S:
					case Keys.D:
					case 191: // The "/" key to prevent searching in Firefox (#125)
						horde.stopEvent(e);
						break;
				}
			};

			proto.handleKeyDown = function (e) {
				this.history.push(e.keyCode);
				this.keyStates[e.keyCode] = true;
				this.supressKeys(e);
			};

			proto.handleKeyUp = function (e) {
				this.keyStates[e.keyCode] = false;
				this.supressKeys(e);
			};

			proto.isKeyDown = function (keyCode) {
				return (this.keyStates[keyCode] === true);
			};

			proto.isKeyPressed = function (keyCode) {
				return (this.isKeyDown(keyCode) && this.lastKeyStates[keyCode] !== true);
			};

			proto.isAnyKeyPressed = function (keyCode) {
				for (var keyCode in this.keyStates) {
					if (this.isKeyDown(keyCode) && this.lastKeyStates[keyCode] !== true) {
						return true;
					}
				}
				return false;
			};

			proto.clearKey = function (keyCode) {
				this.keyStates[keyCode] = false;
			};

			proto.clearKeys = function (keyCode) {
				this.keyStates = {};
			};

			proto.clearHistory = function () {
				this.history = [];
			};

			proto.historyMatch = function (keys) {
				var len = keys.length;
				var toCheck = this.history.slice(-len);
				if (toCheck.length !== len) {
					return false;
				}
				for (var x = 0; x < len; x++) {
					if (keys[x] !== toCheck[x]) {
						return false;	
					}
				}
				return true;
			};

			proto.storeKeyStates = function () {
				for (var keyCode in this.keyStates) {
					this.lastKeyStates[keyCode] = this.keyStates[keyCode];
				}
			};
				
			}());


		(function define_horde_Mouse () {

			horde.Mouse = function (canvas) {
				this.buttonStates = {};
				this.mouseX = 0;
				this.mouseY = 0;
				this.canvas = canvas;
				this.lastButtonStates = {};
				horde.on("mousemove", this.handleMouseMove, canvas, this);
				horde.on("mousedown", this.handleMouseDown, canvas, this);
				horde.on("mouseup", this.handleMouseUp, window, this);

				/*
				// iOS
				horde.on("touchmove", this.handleMouseMove, window, this);
				horde.on("touchstart", this.handleMouseDown, window, this);
				horde.on("touchend", this.handleMouseUp, window, this);	
				*/
			};

			var Mouse = horde.Mouse;
			var proto = Mouse.prototype;

			Mouse.Buttons = {
				LEFT: 0,
				RIGHT: 2
			};

			proto.handleMouseMove = function (e) {
				/*
				// iOS
				var touch = e.touches[0];
				e = {
					clientX: touch.pageX,
					clientY: touch.pageY
				};
				*/

				var offset = horde.getOffset(this.canvas);
				this.mouseX = (((e.clientX - offset.x) * 640) / this.canvas.offsetWidth);
				this.mouseY = (((e.clientY - offset.y) * 480) / this.canvas.offsetHeight);
				this.hasMoved = true;
			};

			proto.handleMouseDown = function (e) {
				// iOS
				/*
				this.buttonStates[Mouse.Buttons.LEFT] = true;
				or e.button = Mouse.Buttons.LEFT;
				*/
				this.buttonStates[e.button] = true;
				horde.stopEvent(e);
				if (window.focus) window.focus();
			};

			proto.handleMouseUp = function (e) {
				// iOS
				/*
				this.buttonStates[Mouse.Buttons.LEFT] = true;
				or e.button = Mouse.Buttons.LEFT;
				*/
				this.buttonStates[e.button] = false;
			};

			proto.isButtonDown = function (button) {
				return this.buttonStates[button];
			};

			proto.isAnyButtonDown = function () {
				for (var key in this.buttonStates) {
					if (this.buttonStates[key]) {
						return true;
					}
				}

				return false;
			};

			proto.clearButtons = function () {
				this.buttonStates = {};
			};

			proto.wasButtonClicked = function (button) {
				return (this.buttonStates[button] && !this.lastButtonStates[button]);
			};

			proto.storeButtonStates = function () {
				for (var key in this.buttonStates) {
					this.lastButtonStates[key] = this.buttonStates[key];
				}
			};

			}());



		horde.isDemo = function () {
			return false;
		};

		horde.populateWaves = function (engine) {

			// FULL GAME WAVES

			// Wave 1: Level 1
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 1000);
			w.addSpawnPoint(1, 1000);
			w.addSpawnPoint(2, 1000);
			w.addObjects(0, "bat", 1);
			w.addObjects(1, "bat", 1);
			w.addObjects(2, "bat", 1);
			engine.waves.push(w);

			// Wave 2
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 1000);
			w.addSpawnPoint(1, 1000);
			w.addSpawnPoint(2, 1000);
			w.addObjects(0, "goblin", 2);
			w.addObjects(1, "goblin", 2);
			w.addObjects(2, "goblin", 2);
			engine.waves.push(w);

			// Wave 3
			var w = new horde.SpawnWave();
			w.addSpawnPoint(1, 1000);
			w.addObjects(1, "cyclops", 1);
			engine.waves.push(w);

			// Wave 4
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 1000);
			w.addSpawnPoint(1, 1000);
			w.addSpawnPoint(2, 1000);
			w.addObjects(0, "demoblin", 2);
			w.addObjects(1, "demoblin", 3);
			w.addObjects(2, "demoblin", 2);
			engine.waves.push(w);

			// Wave 5
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 500);
			w.addSpawnPoint(1, 750);
			w.addSpawnPoint(2, 500);
			w.addObjects(0, "bat", 5);
			w.addObjects(0, "goblin", 2);
			w.addObjects(1, "goblin", 2);
			w.addObjects(1, "cyclops", 1);
			w.addObjects(1, "goblin", 3);
			w.addObjects(2, "bat", 5);
			w.addObjects(2, "goblin", 2);
			engine.waves.push(w);
			
			// Wave 6
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 200);
			w.addSpawnPoint(1, 200);
			w.addSpawnPoint(2, 200);
			w.addObjects(0, "bat", 10);
			w.addObjects(1, "bat", 10);
			w.addObjects(2, "bat", 10);
			engine.waves.push(w);
			
			// Wave 7
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 1000);
			w.addSpawnPoint(1, 1000);
			w.addSpawnPoint(2, 1000);
			w.addObjects(0, "demoblin", 3);
			w.addObjects(1, "cyclops", 1);
			w.addObjects(1, "goblin", 5);
			w.addObjects(2, "demoblin", 3);
			engine.waves.push(w);

			// Wave 8
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 5000);
			w.addSpawnPoint(1, 1500);
			w.addSpawnPoint(2, 5000);
			w.addObjects(0, "imp", 5);
			w.addObjects(1, "imp", 10);
			w.addObjects(2, "imp", 5);
			engine.waves.push(w);

			// Wave 9
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 750);
			w.addSpawnPoint(1, 750);
			w.addSpawnPoint(2, 750);
			w.addObjects(0, "cyclops", 1);
			w.addObjects(2, "cyclops", 1);
			w.addObjects(0, "bat", 10);
			w.addObjects(1, "bat", 10);
			w.addObjects(2, "bat", 10);
			engine.waves.push(w);

			// Wave 10: Gelatinous Cube
			var w = new horde.SpawnWave();
			w.addSpawnPoint(1, 1000);
			w.addObjects(1, "cube", 1);
			w.bossWave = true;
			w.bossName = "Gelatinous Cube";
			engine.waves.push(w);

			// Wave 11: Level 2
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 20000);
			w.addSpawnPoint(1, 20000);
			w.addSpawnPoint(2, 20000);
			w.addObjects(0, "sandworm", 2);
			w.addObjects(1, "sandworm", 2);
			w.addObjects(2, "sandworm", 2);
			engine.waves.push(w);

			// Wave 12
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 10000);
			w.addSpawnPoint(1, 10000);
			w.addSpawnPoint(2, 10000);
			w.addObjects(0, "wizard", 2);
			w.addObjects(1, "wizard", 2);
			w.addObjects(2, "wizard", 2);
			engine.waves.push(w);

			// Wave 13
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 7500);
			w.addSpawnPoint(1, 7500);
			w.addSpawnPoint(2, 7500);
			w.addObjects(0, "flaming_skull", 2);
			w.addObjects(1, "flaming_skull", 2);
			w.addObjects(2, "flaming_skull", 2);
			engine.waves.push(w);

			// Wave 14
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 15000);
			w.addSpawnPoint(1, 1500);
			w.addSpawnPoint(2, 15000);
			w.addObjects(0, "owlbear", 1);
			w.addObjects(2, "owlbear", 1);
			engine.waves.push(w);

			// Wave 15
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 1000);
			w.addSpawnPoint(1, 1000);
			w.addSpawnPoint(2, 1000);
			w.addObjects(0, "huge_skull", 1);
			w.addObjects(1, "huge_skull", 1);
			w.addObjects(2, "huge_skull", 1);
			engine.waves.push(w);

			// Wave 16
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 500);
			w.addSpawnPoint(1, 4000);
			w.addSpawnPoint(2, 500);
			w.addObjects(0, "dire_bat", 5);
			w.addObjects(0, "hunter_goblin", 2);
			w.addObjects(0, "dire_bat", 5);
			w.addObjects(0, "hunter_goblin", 2);
			w.addObjects(1, "sandworm", 2);
			w.addObjects(2, "dire_bat", 5);
			w.addObjects(2, "hunter_goblin", 2);
			w.addObjects(2, "dire_bat", 5);
			w.addObjects(2, "hunter_goblin", 2);
			engine.waves.push(w);

			// Wave 17
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 3000);
			w.addSpawnPoint(1, 1500);
			w.addSpawnPoint(2, 3000);
			w.addObjects(0, "flaming_skull", 2);
			w.addObjects(1, "imp", 5);
			w.addObjects(1, "wizard", 3);
			w.addObjects(2, "flaming_skull", 2);
			engine.waves.push(w);

			// Wave 18
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 1500);
			w.addSpawnPoint(1, 1500);
			w.addSpawnPoint(2, 1500);
			w.addObjects(0, "cyclops", 1);
			w.addObjects(0, "goblin", 5);
			w.addObjects(1, "demoblin", 3);
			w.addObjects(1, "owlbear", 1);
			w.addObjects(1, "demoblin", 5);
			w.addObjects(2, "goblin", 5);
			w.addObjects(2, "cyclops", 1);
			engine.waves.push(w);

			// Wave 19
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 3500);
			w.addSpawnPoint(1, 4000);
			w.addSpawnPoint(2, 5000);
			w.addObjects(0, "wizard", 5);
			w.addObjects(1, "imp", 5);
			w.addObjects(1, "owlbear", 1);
			w.addObjects(2, "sandworm", 3);
			engine.waves.push(w);

			// Wave 20: Minotaur
			var w = new horde.SpawnWave();
			w.addSpawnPoint(1, 1000);
			w.addObjects(1, "superclops", 1);
			w.bossWave = true;
			w.bossName = "Minotaur"
			engine.waves.push(w);
			
			// Wave 21: Level 3
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 100);
			w.addSpawnPoint(1, 100);
			w.addSpawnPoint(2, 100);
			w.addObjects(0, "bat", 15);
			w.addObjects(1, "dire_bat", 15);
			w.addObjects(2, "bat", 15);
			engine.waves.push(w);

			// Wave 22
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 1500);
			w.addSpawnPoint(1, 1500);
			w.addSpawnPoint(2, 1500);
			w.addObjects(0, "goblin", 15);
			w.addObjects(1, "hunter_goblin", 15);
			w.addObjects(2, "goblin", 15);
			engine.waves.push(w);

			// Wave 23
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 2000);
			w.addSpawnPoint(1, 2000);
			w.addSpawnPoint(2, 2000);
			w.addObjects(0, "demoblin", 12);
			w.addObjects(1, "demoblin", 12);
			w.addObjects(2, "demoblin", 12);
			engine.waves.push(w);

			// Wave 24
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 25000);
			w.addSpawnPoint(1, 25000);
			w.addSpawnPoint(2, 25000);
			w.addObjects(0, "cyclops", 2);
			w.addObjects(1, "cyclops", 2);
			w.addObjects(2, "cyclops", 2);
			engine.waves.push(w);
			
			// Wave 25
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 3000);
			w.addSpawnPoint(1, 3000);
			w.addSpawnPoint(2, 3000);
			w.addObjects(0, "imp", 10);
			w.addObjects(1, "imp", 10);
			w.addObjects(2, "imp", 10);
			engine.waves.push(w);
			
			// Wave 26
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 25000);
			w.addSpawnPoint(1, 25000);
			w.addSpawnPoint(2, 25000);
			w.addObjects(0, "owlbear", 2);
			w.addObjects(1, "owlbear", 2);
			w.addObjects(2, "owlbear", 2);
			engine.waves.push(w);
			
			// Wave 27
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 12000);
			w.addSpawnPoint(1, 12000);
			w.addSpawnPoint(2, 12000);
			w.addObjects(0, "wizard", 4);
			w.addObjects(1, "wizard", 4);
			w.addObjects(2, "wizard", 4);
			engine.waves.push(w);
			
			// Wave 28
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 15000);
			w.addSpawnPoint(1, 20000);
			w.addSpawnPoint(2, 15000);
			w.addObjects(0, "flaming_skull", 5);
			w.addObjects(1, "huge_skull", 3);
			w.addObjects(2, "flaming_skull", 5);
			engine.waves.push(w);
			
			// Wave 29
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 15000);
			w.addSpawnPoint(1, 15000);
			w.addSpawnPoint(2, 15000);
			w.addObjects(0, "sandworm", 5);
			w.addObjects(1, "sandworm", 5);
			w.addObjects(2, "sandworm", 5);
			engine.waves.push(w);
			
			// Wave 30: Green Dragon
			var w = new horde.SpawnWave();
			w.addSpawnPoint(1, 1000);
			w.addObjects(1, "dragon", 1);
			w.bossWave = true;
			w.bossName = "Green Dragon"
			engine.waves.push(w);

			// Wave 31: Level 4
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 3500);
			w.addSpawnPoint(1, 3500);
			w.addSpawnPoint(2, 3500);
			w.addObjects(0, "goblin", 25);
			w.addObjects(1, "demoblin", 25);
			w.addObjects(2, "hunter_goblin", 25);
			engine.waves.push(w);

			// Wave 32
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 7500);
			w.addSpawnPoint(1, 5000);
			w.addSpawnPoint(2, 7500);
			w.addObjects(0, "sandworm", 2);
			w.addObjects(0, "wizard", 3);
			w.addObjects(1, "imp", 10);
			w.addObjects(2, "sandworm", 2);
			w.addObjects(2, "wizard", 3);
			engine.waves.push(w);

			// Wave 33
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 15000);
			w.addSpawnPoint(1, 7500);
			w.addSpawnPoint(2, 15000);
			w.addObjects(0, "owlbear", 3);
			w.addObjects(1, "flaming_skull", 6);
			w.addObjects(2, "owlbear", 3);
			engine.waves.push(w);

			// Wave 34
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 2500);
			w.addSpawnPoint(1, 15000);
			w.addSpawnPoint(2, 2500);
			w.addObjects(0, "demoblin", 10);
			w.addObjects(0, "goblin", 10);
			w.addObjects(1, "cyclops", 1);
			w.addObjects(1, "owlbear", 1);
			w.addObjects(1, "cyclops", 1);
			w.addObjects(1, "owlbear", 1);
			w.addObjects(2, "demoblin", 10);
			w.addObjects(2, "goblin", 10);
			engine.waves.push(w);

			// Wave 35
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 12500);
			w.addSpawnPoint(1, 20000);
			w.addSpawnPoint(2, 12500);
			w.addObjects(0, "sandworm", 5);
			w.addObjects(1, "huge_skull", 1);
			w.addObjects(1, "owlbear", 1);
			w.addObjects(1, "cyclops", 1);
			w.addObjects(1, "huge_skull", 1);
			w.addObjects(2, "sandworm", 5);
			engine.waves.push(w);

			// Wave 36
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 20000);
			w.addSpawnPoint(1, 1000);
			w.addSpawnPoint(2, 20000);
			w.addObjects(0, "cyclops", 1);
			w.addObjects(0, "flaming_skull", 1);
			w.addObjects(1, "wizard", 8);
			w.addObjects(2, "cyclops", 1);
			w.addObjects(2, "flaming_skull", 1);
			engine.waves.push(w);

			// Wave 37
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 4000);
			w.addSpawnPoint(1, 10000);
			w.addSpawnPoint(2, 4000);
			w.addObjects(0, "demoblin", 8);
			w.addObjects(1, "owlbear", 2);
			w.addObjects(2, "demoblin", 8);
			engine.waves.push(w);

			// Wave 38
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 5000);
			w.addSpawnPoint(1, 7500);
			w.addSpawnPoint(2, 5000);
			w.addObjects(0, "sandworm", 1);
			w.addObjects(0, "wizard", 3);
			w.addObjects(1, "flaming_skull", 4);
			w.addObjects(1, "huge_skull", 1);
			w.addObjects(2, "sandworm", 1);
			w.addObjects(2, "wizard", 3);
			engine.waves.push(w);
			
			// Wave 39
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 2000);
			w.addSpawnPoint(1, 2500);
			w.addSpawnPoint(2, 2000);
			w.addObjects(0, "goblin", 30);
			w.addObjects(1, "demoblin", 25);
			w.addObjects(2, "hunter_goblin", 30);
			engine.waves.push(w);

			// Wave 40: Beholder
			var w = new horde.SpawnWave();
			w.addSpawnPoint(1, 1000);
			w.addObjects(1, "beholder", 1);
			w.bossWave = true;
			w.bossName = "Beholder"
			engine.waves.push(w);
			
			// Wave 41: Level 5
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 3000);
			w.addSpawnPoint(1, 3000);
			w.addSpawnPoint(2, 3000);
			w.addObjects(0, "cyclops", 2);
			w.addObjects(1, "owlbear", 2);
			w.addObjects(2, "cyclops", 2);
			engine.waves.push(w);

			// Wave 42
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 1000);
			w.addSpawnPoint(1, 1000);
			w.addSpawnPoint(2, 1000);
			w.addObjects(0, "wizard", 3);
			w.addObjects(0, "flaming_skull", 1);
			w.addObjects(1, "wizard", 3);
			w.addObjects(1, "huge_skull", 1);
			w.addObjects(2, "wizard", 3);
			w.addObjects(2, "flaming_skull", 1);
			engine.waves.push(w);

			// Wave 43
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 3000);
			w.addSpawnPoint(1, 3000);
			w.addSpawnPoint(2, 3000);
			w.addObjects(0, "sandworm", 3);
			w.addObjects(0, "owlbear", 1);
			w.addObjects(1, "sandworm", 3);
			w.addObjects(1, "huge_skull", 1);
			w.addObjects(2, "sandworm", 3);
			w.addObjects(2, "cyclops", 1);
			engine.waves.push(w);

			// Wave 44
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 200);
			w.addSpawnPoint(1, 200);
			w.addSpawnPoint(2, 200);
			w.addObjects(0, "dire_bat", 20);
			w.addObjects(0, "wizard", 2);
			w.addObjects(0, "cyclops", 1);
			w.addObjects(1, "dire_bat", 20);
			w.addObjects(1, "sandworm", 2);
			w.addObjects(1, "owlbear", 1);
			w.addObjects(2, "dire_bat", 20);
			w.addObjects(2, "wizard", 2);
			w.addObjects(2, "cyclops", 1);
			engine.waves.push(w);

			// Wave 45
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 3000);
			w.addSpawnPoint(1, 3000);
			w.addSpawnPoint(2, 3000);
			w.addObjects(0, "goblin", 10);
			w.addObjects(0, "cyclops", 1);
			w.addObjects(0, "wizard", 3);
			w.addObjects(1, "demoblin", 10);
			w.addObjects(1, "huge_skull", 1);
			w.addObjects(1, "sandworm", 3);
			w.addObjects(2, "hunter_goblin", 10);
			w.addObjects(2, "owlbear", 1);
			w.addObjects(2, "flaming_skull", 3);
			engine.waves.push(w);

			// Wave 46
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 2500);
			w.addSpawnPoint(1, 1000);
			w.addSpawnPoint(2, 2500);
			w.addObjects(0, "wizard", 4);
			w.addObjects(1, "cube", 1);
			w.addObjects(2, "wizard", 4);
			engine.waves.push(w);

			// Wave 47
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 1000);
			w.addSpawnPoint(1, 1000);
			w.addSpawnPoint(2, 1000);
			w.addObjects(0, "demoblin", 5);
			w.addObjects(1, "superclops", 1);
			w.addObjects(1, "demoblin", 4);
			w.addObjects(2, "demoblin", 5);
			engine.waves.push(w);

			// Wave 48
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 30000);
			w.addSpawnPoint(1, 1000);
			w.addSpawnPoint(2, 30000);
			w.addObjects(0, "sandworm", 1);
			w.addObjects(0, "owlbear", 1);
			w.addObjects(1, "dragon", 1);
			w.addObjects(2, "sandworm", 1);
			w.addObjects(2, "owlbear", 1);
			engine.waves.push(w);

			// Wave 49
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 15000);
			w.addSpawnPoint(1, 1000);
			w.addSpawnPoint(2, 15000);
			w.addObjects(0, "wizard", 1);
			w.addObjects(0, "cyclops", 1);
			w.addObjects(1, "beholder", 1);
			w.addObjects(2, "wizard", 1);
			w.addObjects(2, "cyclops", 1);
			engine.waves.push(w);

			// Wave 50: Doppelganger
			var w = new horde.SpawnWave();
			w.addSpawnPoint(1, 1000);
			w.addObjects(1, "doppelganger", 1);
			w.bossWave = true;
			w.bossName = "Doppelganger"
			engine.waves.push(w);
			
		};


		(function define_horde_Engine () {

			var VERSION = "{{VERSION}}";
			var SCREEN_WIDTH = 640;
			var SCREEN_HEIGHT = 480;
			var URL_STORE = "https://chrome.google.com/extensions/detail/khodnfbkbanejphecblcofbghjdgfaih";

			var DEFAULT_HIGH_SCORE = 1000;
			var HIGH_SCORE_KEY = "high_score";

			var COLOR_BLACK = "rgb(0, 0, 0)";
			var COLOR_WHITE = "rgb(241, 241, 242)";
			var TEXT_HEIGHT = 20; // Ehh, kind of a hack, because stupid ctx.measureText only gives width (why??).
			var WAVE_TEXT_HEIGHT = 40;

			var OVERLAY_ALPHA = 0.7;
			var POINTER_HEIGHT = 24;
			var POINTER_X = 270;

			var TUTORIAL_HEIGHT = 70;
			var TUTORIAL_NUM_TIPS = 4;

			var GLOW_INCREMENT = 0.2;
			var GATE_CUTOFF_Y = 64;
			var NUM_GATES = 3;
			var SCORE_COUNT = 10;

			/**
			 * Creates a new Engine object
			 * @constructor
			 */
			horde.Engine = function horde_Engine () {
				this.lastUpdate = 0;
				this.canvases = {};
				this.map = null;
				this.spawnPoints = [];
				this.objects = {};
				this.objectIdSeed = 0;
				this.playerObjectId = null;
				this.keyboard = new horde.Keyboard();
				this.view = new horde.Size(SCREEN_WIDTH, SCREEN_HEIGHT);
				this.images = null;
				this.debug = false; // Debugging toggle
				this.konamiEntered = false;

				// Clay.io: Load in the API
				this.Clay = Clay = window.Clay = {};
				Clay.gameKey = "onslaughtarena";
				Clay.readyFunctions = [];
				Clay.options = {
					//debug: true
				};
				Clay.ready = function( fn ) {
					Clay.readyFunctions.push( fn );
				};
				( function() {
				var clay = document.createElement("script");
				clay.src = ( "https:" == document.location.protocol ? "https://" : "http://" ) + "clay.io/api/api-src.js";
				var tag = document.getElementsByTagName("script")[0]; tag.parentNode.insertBefore(clay, tag);
				} )();

				this.clayLeaderboard = { show: function() { console.log( "Clay.io leaderboard not ready yet!" ) } };

				var _this = this;
				Clay.ready( function() {
					_this.loggedIn = Clay.Player.loggedIn;
					_this.clayLeaderboard = new Clay.Leaderboard({ id: 385, filters: ['day', 'month', 'all'],
											tabs: [
												{ title: 'Cumulative', id: 385, cumulative: true, limit: 20, filters: ['day', 'month', 'all'] },
												{ title: 'My Best', id: 385, self: true, limit: 10 }
											]  });
				} );

				// Storage for each time putData is called - periodically that info is stored to Clay.io as well
				horde.localData = {};
				// Log which achievements have been granted so we don't keep trying to grant them
				horde.achievementsGranted = {};

				this.running = false;

				this.gateDirection = ""; // Set to "up" or "down"
				this.gateState = "down"; // "up" or "down"
				this.gatesX = 0;
				this.gatesY = 0;

				// Sword pointer
				this.pointerY = 0;
				this.pointerYStart = 0;
				this.maxPointerY = 0;
				this.pointerOptionsStart = 0;

				this.targetReticle = {
					position: new horde.Vector2(),
					angle: 0,
					moving: false
				};

				this.enableFullscreen = false;
				this.enableClouds = false;
				this.cloudTimer = null;
				this.woundsToSpeed = 10;

				this.introTimer = new horde.Timer();
				this.introPhase = 0;
				this.introPhaseInit = false;

				this.wonGame = false;
				this.wonGamePhase = 0;

				this.weaponPickup = {
					type: null,
					state: "off",
					alpha: 1,
					scale: 1,
					position: new horde.Vector2()
				};

				this.coinPickup = {
					amount: 0,
					state: "off",
					alpha: 1,
					position: new horde.Vector2()
				};

				// Flag enabling/disabling touch device mode
				this.touchMove = false;

				this.canMute = true;
				this.canFullscreen = false;
				this.wasdMovesArrowsAttack = true;

			};

			var proto = horde.Engine.prototype;

			proto.cacheBust = function () {
				if (VERSION.indexOf("VERSION") !== -1) {
					return "?cachebust=" + horde.Timer.now();
				} else {
					return "?cachebust=" + VERSION;
				}
			};

			proto.resize = function horde_Engine_proto_resize () {
				var windowWidth = window.innerWidth;
				var windowHeight = window.innerHeight;
				var stage = document.getElementById("stage");
				var stageHeight = (windowHeight - stage.offsetTop);
				stage.style.height = stageHeight + "px";
				if (this.enableFullscreen) {
					height = (stageHeight - 50);
					if (height < 480) {
						height = 480;
					}
					if (height > 768) {
						height = 768;
					}
					var width = Math.round(height * 1.333);
				} else {
					width = 640;
					height = 480;
				}
				var c = this.canvases["display"];
				// iOS
				/*
				Basically width/height on the canvas needs to be the entire resolution of the viewport.
				So like on iPad that's 1024x768. Just remove all chrome (like the nav) from the page and resize the canvas to 100%.
				*/
				c.style.width = width + "px";
				c.style.height = height + "px";
				var gameLeft = Math.max((windowWidth / 2) - (width / 2), 0);
				var gameTop = Math.max((stageHeight / 2) - (height / 2), 30);
				c.style.left = gameLeft + "px";
				c.style.top = gameTop + "px";
				var tip = document.getElementById("tip");
				if (tip) {
					tip.style.top = (gameTop - 30) + "px";
					tip.style.left = gameLeft + "px";
					tip.style.width = width + "px";
				}
			};

			/**
			 * Runs the engine
			 * @return {void}
			 */
			proto.run = function horde_Engine_proto_run () {
				this.init();
				this.lastUpdate = horde.now();
				this.start();
			};

			/**
			 * Starts the engine
			 * @return {void}
			 */
			proto.start = function horde_Engine_proto_start () {
				if (!this.running) {
					this.running = true;
					this.requestFrame();
				}
			};

			/**
			 * Stops the engine
			 * @return {void}
			 */
			proto.stop = function horde_Engine_proto_stop () {
				if (this.running) {
					this.running = false;
				}
			};

			/**
			 * Toggles pausing the engine
			 * Note: isMuted would be used by every instance since it's within its own closure. Ew!
			 * @return {void}
			 */
			proto.togglePause = (function horde_Engine_proto_togglePause () {

				var isMuted = false;

				return function horde_Engine_proto_togglePause () {

					if (this.getPlayerObject().hasState(horde.Object.states.DYING)) {
						return;
					}

					if (this.paused) {
						this.paused = false;
						horde.sound.setMuted(isMuted);
						horde.sound.play("unpause");
						horde.sound.play(this.currentMusic);
					} else {
						this.paused = true;
						this.initOptions();
						isMuted = horde.sound.isMuted();
						horde.sound.play("pause");
						horde.sound.stop(this.currentMusic);
					}

				};

			})();

			/**
			 * Adds an object to the engine's collection
			 * @param {horde.Object} Object to add
			 * @return {number} ID of the newly added object
			 */
			proto.addObject = function horde_Engine_proto_addObject (object) {
				this.objectIdSeed++;
				var id = "o" + this.objectIdSeed;
				object.id = id;
				this.objects[id] = object;
				return id;
			};

			/**
			 * Returns the RGB for either red, orange or green depending on the percentage.
			 * @param {Number} max The max number, eg 100.
			 * @param {Number} current The current number, eg 50 (which would be 50%).
			 * @return {String} The RGB value based on the percentage.
			 */
			proto.getBarColor = function (max, current) {

				var percentage = ((current / max) * 100);

				if (percentage > 50) {
					return "rgb(98, 187, 70)";
				} else if (percentage > 25) {
					return "rgb(246, 139, 31)";
				} else {
					return "rgb(238, 28, 36)";
				}

			};

			/**
			 * Spawns an object from a parent object
			 * @param {horde.Object} parent Parent object
			 * @param {string} type Type of object to spawn
			 * @return {void}
			 */
			proto.spawnObject = function horde_Engine_proto_spawnObject (
				parent,
				type,
				facing,
				takeOwnership
			) {
				var f = facing || parent.facing;
				var o = horde.makeObject(type, true);
				var owner = parent;
				while (owner.ownerId !== null) {
					if (this.objects[owner.ownerId]) {
						owner = this.objects[owner.ownerId];
					} else {
						break;
					}
				}
				if (takeOwnership !== false) {
					o.ownerId = owner.id;
					o.team = parent.team;
				}
				o.centerOn(parent.boundingBox().center());
				o.setDirection(f);
				o.init();
				return this.addObject(o);
			};

			proto.objectExists = function (objectId) {
				return (this.objects[objectId]);
			};

			/**
			 * Returns the currently "active" object
			 * In our case this is the player avatar
			 * @return {horde.Object} Player object
			 */
			proto.getPlayerObject = function horde_Engine_proto_getPlayerObject () {
				return this.objects[this.playerObjectId];
			};

			proto.getObjectCountByType = function horde_Engine_proto_getObjectCountByType (type) {
				var count = 0;
				for (var id in this.objects) {
					var obj = this.objects[id];
					if (obj.type === type) {
						count++;
					}
				}
				return count;
			};

			proto.isAlive = function horde_Engine_proto_isAlive (objectId) {
				if (this.objects[objectId]) {
					var o = this.objects[objectId];
					return (o.alive && o.wounds < o.hitPoints);
				}
				return false;
			};

			proto.preloadComplete = function () {
				this.state = "intro";
				this.logoAlpha = 0;
				this.logoFade = "in";
				this.logoFadeSpeed = 0.5;
			};

			/**
			 * Initializes the engine
			 * @return {void}
			 */
			proto.init = function horde_Engine_proto_init () {

				this.state = "intro";

				this.canvases["display"] = horde.makeCanvas("display", this.view.width, this.view.height);
				this.canvases["buffer"] = horde.makeCanvas("buffer", this.view.width, this.view.height, true);
				this.canvases["waveText"] = horde.makeCanvas("waveText", this.view.width, this.view.height, true);

				this.resize();
				horde.on("resize", this.resize, window, this);

				this.mouse = new horde.Mouse(this.canvases["display"]);

				horde.on("contextmenu", function (e) {
					horde.stopEvent(e);
				}, document.body, this);

				horde.on("blur", function () {
					if (this.state != "running" || this.wonGame) return;
					this.keyboard.keyStates = {};
					if (!this.paused) {
						this.togglePause();
					}
					this.stop();
				}, window, this);

				horde.on("focus", function () {
					this.start();
				}, window, this);

/* 				// Load just the logo
				this.preloader = new horde.ImageLoader();
				this.preloader.load({
					"ui": "img/sheet_ui.png" + this.cacheBust()
				}, this.preloadComplete, this);

				// Load the rest of the image assets
				this.images = new horde.ImageLoader();
				this.images.load({
					"arena": "img/sheet_arena.png" + this.cacheBust(),
					"characters": "img/sheet_characters.png" + this.cacheBust(),
					"objects": "img/sheet_objects.png" + this.cacheBust(),
					"beholder": "img/sheet_beholder.png" + this.cacheBust(),
				}, this.handleImagesLoaded, this);

				console.log(horde) */

				// Load just the logo
				this.preloader = new horde.ImageLoader();
				this.preloader.load({
					"ui": "https://raw.githubusercontent.com/CopeBears/AtariFiles/main/imgOnslaught/sheet_ui.png" 
				}, this.preloadComplete, this);

				// Load the rest of the image assets
				this.images = new horde.ImageLoader();
				this.images.load({
					"arena": "https://raw.githubusercontent.com/CopeBears/AtariFiles/main/imgOnslaught/sheet_arena.png",
					"characters": "https://raw.githubusercontent.com/CopeBears/AtariFiles/main/imgOnslaught/sheet_characters.png",
					"objects": "https://raw.githubusercontent.com/CopeBears/AtariFiles/main/imgOnslaught/sheet_objects.png",
					"beholder": "https://raw.githubusercontent.com/CopeBears/AtariFiles/main/imgOnslaught/sheet_beholder.png"
				}, this.handleImagesLoaded, this);



				var highScore = this.getData(HIGH_SCORE_KEY);
				if (highScore === null) {
					this.putData(HIGH_SCORE_KEY, DEFAULT_HIGH_SCORE);
				}

				this.initSound();

			};

			/**
			 * Initializes music and sound effects
			 * @return {void}
			 */
			proto.initSound = function horde_Engine_proto_initSound () {

				horde.sound.init(function () {

					// Create all sound files
					var musicDir = "sound/music/";
					var sfxDir = "sound/effects/";
					var s = horde.sound;

					// Music
					s.create("normal_battle_music", musicDir + "normal_battle", true, 20);
					s.create("final_battle_music", musicDir + "final_battle", true, 20);
					s.create("victory", musicDir + "victory", true, 20);

					// UI
					s.create("move_pointer", sfxDir + "move_pointer", false, 50);
					s.create("select_pointer", sfxDir + "select_pointer", false, 50);
					s.create("pause", sfxDir + "pause");
					s.create("unpause", sfxDir + "unpause");

					// Environment
					s.create("code_entered", sfxDir + "code_entered");
					s.create("gate_opens", sfxDir + "gate_opens");
					s.create("gate_closes", sfxDir + "gate_closes");
					s.create("spike_attack", sfxDir + "spike_attacks");

					// Misc
					s.create("immunity", sfxDir + "immunity", false, 25);
					s.create("coins", sfxDir + "coins", false, 10);
					s.create("eat_food", sfxDir + "eat_food", false, 30);
					s.create("pickup_weapon", sfxDir + "pickup_weapon");
					s.create("weapon_wall", sfxDir + "weapon_wall", false, 25);

					// Hero
					s.create("fire_attack", sfxDir + "char_attacks_fire");
					s.create("hero_attacks", sfxDir + "char_attacks");
					s.create("hero_damage", sfxDir + "char_damage_3");
					s.create("hero_dies", sfxDir + "char_dies");

					// Bat
					// Attack: not needed
					s.create("bat_damage", sfxDir + "bat_damage");
					s.create("bat_dies", sfxDir + "bat_dies");

					// Goblin
					s.create("goblin_attacks", sfxDir + "goblin_attacks");
					s.create("goblin_damage", sfxDir + "goblin_damage");
					s.create("goblin_dies", sfxDir + "goblin_dies");

					// Demoblin
					s.create("demoblin_attacks", sfxDir + "demoblin_attacks", false, 80);
					// Damage: goblin_damage
					// Dies: goblin_dies

					// Imp
					// Attack: not needed
					s.create("imp_damage", sfxDir + "imp_damage", false, 30);
					s.create("imp_dies", sfxDir + "imp_dies", false, 30);

					// Gel
					// Attack: not needed
					s.create("gel_damage", sfxDir + "gel_damage", false, 20);
					s.create("gel_dies", sfxDir + "gel_dies", false, 20);

					// Flaming Skull
					// Attack: not needed
					s.create("skull_damage", sfxDir + "skull_damage", false, 25);
					s.create("skull_dies", sfxDir + "skull_dies", false, 5);

					// Wizard
					s.create("wizard_attacks", sfxDir + "wizard_attacks", false, 25);
					// Damage: goblin_damage
					// Dies: goblin_dies
					s.create("wizard_disappear", sfxDir + "wizard_disappear", false, 50);
					s.create("wizard_reappear", sfxDir + "wizard_reappear", false, 50);

					// Sandworm
					s.create("sandworm_attacks", sfxDir + "sandworm_attacks", false, 75);
					// Damage: goblin_damage
					s.create("sandworm_dies", sfxDir + "sandworm_dies", false, 40);

					// Cyclops
					s.create("cyclops_attacks", sfxDir + "cyclops_attacks");
					s.create("cyclops_damage", sfxDir + "cyclops_damage");
					s.create("cyclops_dies", sfxDir + "cyclops_dies");

					// Owlbear
					s.create("owlbear_alarm", sfxDir + "owlbear_alarm", false, 20);
					s.create("owlbear_attacks", sfxDir + "owlbear_attacks", false, 15);
					s.create("owlbear_damage", sfxDir + "owlbear_damage", false, 40);
					s.create("owlbear_dies", sfxDir + "owlbear_dies", false, 50);

					// Boss 1/5: Gelatinous Cube
					s.create("cube_attacks", sfxDir + "cube_attacks");
					s.create("cube_damage", sfxDir + "cube_damage");
					s.create("cube_dies", sfxDir + "cube_dies");

					// Minotaur
					s.create("minotaur_attacks", sfxDir + "minotaur_attacks");
					s.create("minotaur_damage", sfxDir + "minotaur_damage");
					s.create("minotaur_dies", sfxDir + "minotaur_dies");

					// Boss 3/5: Green Dragon
					s.create("dragon_attacks", sfxDir + "dragon_attacks");
					s.create("dragon_damage", sfxDir + "dragon_damage");
					s.create("dragon_dies", sfxDir + "dragon_dies");

					// Boss 4/5: Beholder
					s.create("beholder_damage", sfxDir + "beholder_damage", false, 50);
					s.create("beholder_dies", sfxDir + "beholder_dies", false, 25);

					// Add: Eyelet
					s.create("eyelet_damage", sfxDir + "eyelet_damage", false, 25);
					s.create("eyelet_dies", sfxDir + "eyelet_dies", false, 25);

					// Boss 5/5: Doppelganger
					s.create("dopp_attacks", sfxDir + "dopp_attacks", false, 50);
					s.create("dopp_damage", sfxDir + "dopp_damage", false, 50);
					s.create("dopp_dies", sfxDir + "dopp_dies");

				});

			};

			proto.initGame = function () {

				this.konamiEntered = false;
				this.enableClouds = false;

				this.closeGates();

				this.objects = {};
				this.state = "title";
				this.initOptions();

				this.initMap();

				this.initSpawnPoints();
				this.initWaves();

				this.initPlayer();

				this.gameOverBg = null;

				this.monstersAlive = 0;

				this.gotNewHighScore = 0;
				this.scoreCount = 0;
				this.statsCount = 0;
				this.statsIncrement = 0;
				this.statsIndex = 0;
				this.statsTimer = null;
				this.highScoreSaved = false;

				this.wonGame = false;
				this.wonGamePhase = 0;

				this.showReticle = false;
				this.hideReticleTimer = null;

				this.showTutorial = false;
				this.tutorialIndex = 0;
				this.tutorialY = -TUTORIAL_HEIGHT;
				this.tutorialDirection = "down";
				this.hideTutorialTimer = null;
				this.nextTutorialTimer = null;

				this.heroFiring = false;
				this.heroFiringDirection = null;
				this.woundsTo = 0;

				this.gameStartTime = horde.now();

			};

			/**
			 * Initializes the map
			 * @return {void}
			 */
			proto.initMap = function horde_Engine_proto_initMap () {
				this.tileSize = new horde.Size(32, 32);
				this.map = [
					[0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0],
					[0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0],
					[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
					[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
					[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
					[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
					[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
					[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
					[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
					[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
					[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
					[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
				];
			};

			/**
			 * Initialize the spawn points
			 * @return {void}
			 */
			proto.initSpawnPoints = function horde_Engine_proto_initSpawnPoints () {

				this.spawnPoints = [];

				// Left gate (index 0)
				this.spawnPoints.push(new horde.SpawnPoint(
					3 * this.tileSize.width, -2 * this.tileSize.height,
					this.tileSize.width * 2, this.tileSize.height * 2
				));

				// Center gate (index 1)
				this.spawnPoints.push(new horde.SpawnPoint(
					9 * this.tileSize.width, -2 * this.tileSize.height,
					this.tileSize.width * 2, this.tileSize.height * 2
				));

				// Right gate (index 2)
				this.spawnPoints.push(new horde.SpawnPoint(
					15 * this.tileSize.width, -2 * this.tileSize.height,
					this.tileSize.width * 2, this.tileSize.height * 2
				));

			};

			/**
			 * Queues up a wave of spawns in the spawn points
			 * @param {horde.SpawnWave} Wave to spawn
			 * @return {void}
			 */
			proto.initSpawnWave = function horde_Engine_proto_initSpawnWave (wave) {
				var longestTTS = 0;
				for (var x in wave.points) {
					var p = wave.points[x];
					var sp = this.spawnPoints[p.spawnPointId];
					sp.delay = p.delay;
					sp.lastSpawnElapsed = sp.delay;
					for (var z in p.objects) {
						var o = p.objects[z];
						sp.queueSpawn(o.type, o.count);
					}
					var timeToSpawn = ((sp.queue.length - 1) * sp.delay);
					if (timeToSpawn > longestTTS) {
						longestTTS = timeToSpawn;
					}
				}
				var ttl = longestTTS + wave.nextWaveTime;
				this.waveTimer.start(ttl);
				this.openGates();
			};

			/**
			 * Initializes the waves of bad guys!
			 * @return {void}
			 */
			proto.initWaves = function horde_Engine_proto_initWaves () {

				this.waves = [];
				this.waveTimer = new horde.Timer();
				this.waveTimer.start(1);
				this.currentWaveId = -1;

				this.waveText = {
					string: "",
					size: 20,
					state: "off",
					alpha: 0
				};

				// Wave testing code...
				/*
				var testWave = 50;
				this.waveHack = true;
				this.currentWaveId = (testWave - 2);
				*/

				// Test Wave
				/*
				var w = new horde.SpawnWave();
				w.addSpawnPoint(0, 1000);
				w.addSpawnPoint(1, 1000);
				w.addSpawnPoint(2, 1000);
				w.addObjects(0, "huge_skull", 1);
				w.addObjects(1, "huge_skull", 1);
				w.addObjects(2, "huge_skull", 1);
				w.nextWaveTime = Infinity;
				this.waves.push(w);
				*/

				horde.populateWaves(this);

			};

			/**
			 * Initializes the player
			 * @return {void}
			 */
			proto.initPlayer = function horde_Engine_proto_initPlayer () {
				var player = horde.makeObject("hero");
				// NOTE: below line shouldn't be necessary, but it fixes the weapon retention bug for now.
				player.weapons = [
					{type: "h_sword", count: null}
				];
				player.centerOn(horde.Vector2.fromSize(this.view).scale(0.5));
				this.playerObjectId = this.addObject(player);
				if (this.touchMove) {
					this.targetReticle.position = player.boundingBox().center();
				}
			};

			proto.handleImagesLoaded = function horde_Engine_proto_handleImagesLoaded () {
				this.imagesLoaded = true;
			};

			proto.logoFadeOut = function () {
				this.logoFade = "out";
			};

			proto.updateLogo = function (elapsed) {

				var kb = this.keyboard;
				var keys = horde.Keyboard.Keys;

				if (this.keyboard.isAnyKeyPressed() || this.mouse.isAnyButtonDown()) {
					kb.clearKeys();
					this.mouse.clearButtons();
					this.initGame();
				}

				if (this.logoFade === "in") {
					this.logoAlpha += ((this.logoFadeSpeed / 1000) * elapsed);
					if (this.logoAlpha >= 1) {
						this.logoAlpha = 1;
						this.logoFade = "none";
						horde.setTimeout(1000, this.logoFadeOut, this);
					}
				} else if (this.logoFade === "out") {
					this.logoAlpha -= ((this.logoFadeSpeed / 1000) * elapsed);
					if (this.logoAlpha <= 0) {
						this.logoAlpha = 0;
						this.logoFade = "none";
						this.initGame();
					}
				}
			};

			proto.updateIntroCinematic = function horde_Engine_proto_updateIntroCinematic (elapsed) {

				this.introTimer.update(elapsed);

				switch (this.introPhase) {

					// Fade out
					case 0:
						if (!this.introPhaseInit) {
							this.introFadeAlpha = 0;
							this.introPhaseInit = true;
						}
						this.introFadeAlpha += (1 / 1000) * elapsed;
						if (this.introFadeAlpha >= 1) {
							this.introFadeAlpha = 1;
							this.introPhase++;
							this.introPhaseInit = false;
						}
						break;

					// Fade in
					case 1:
						if (!this.introPhaseInit) {
							this.introFadeAlpha = 1;
							this.introPhaseInit = true;
						}
						this.introFadeAlpha -= (0.5 / 1000) * elapsed;
						if (this.introFadeAlpha <= 0) {
							this.introFadeAlpha = 0;
							this.introPhase++;
							this.introPhaseInit = false;
						}
						break;

					// Wait for a sec...
					case 2:
						if (!this.introPhaseInit) {
							this.introTimer.start(1000);
							this.introPhaseInit = true;
						}
						if (this.introTimer.expired()) {
							this.introPhase++;
							this.introPhaseInit = false;
						}
						break;

					// Open the gates
					case 3:
						if (!this.introPhaseInit) {
							this.openGates();
							this.introPhaseInit = true;
						}
						if (this.gateState === "up") {
							this.introPhase++;
							this.introPhaseInit = false;
						}
						break;

					// Move hero out
					case 4:
						if (!this.introPhaseInit) {
							var h = horde.makeObject("hero");
							h.position.x = 304;
							h.position.y = -64;
							h.collidable = false;
							h.setDirection(new horde.Vector2(0, 1));
							this.introHero = h;
							this.introPhaseInit = true;
						}
						this.introHero.update(elapsed);
						this.moveObject(this.introHero, elapsed);
						if (this.introHero.position.y >= 222) {
							this.introHero.centerOn(horde.Vector2.fromSize(this.view).scale(0.5));
							this.introHero.stopMoving();
							this.introPhase++;
							this.introPhaseInit = false;
						}
						break;

					case 5:
					case 6:
					case 8:
						if (!this.introPhaseInit) {
							this.introTimer.start(500);
							this.introPhaseInit = true;
						}
						if (this.introTimer.expired()) {
							this.introPhase++;
							this.introPhaseInit = false;
						}
						break;

					case 7:
						if (!this.introPhaseInit) {
							this.closeGates();
							this.introPhaseInit = true;
						}
						if (this.gateState === "down") {
							this.introPhase++;
							this.introPhaseInit = false;
						}
						break;

					case 9:
						if (!this.introPhaseInit) {
							this.introTimer.start(1000);
							this.introPhaseInit = true;
						}
						this.introHero.update(elapsed);
						if (this.introTimer.expired()) {
							this.currentMusic = "normal_battle_music";
							horde.sound.play(this.currentMusic);
							this.state = "running";
						}
						break;

				}

			};

			proto.update = function horde_Engine_proto_update () {

				var now = horde.now();
				var elapsed = (now - this.lastUpdate);
				this.lastUpdate = now;

				this.lastElapsed = elapsed;

				if (this.imagesLoaded !== true) {
					this.requestFrame();
					return;
				}

				switch (this.state) {

					case "intro":
						this.updateLogo(elapsed);
						this.render();
						break;

					case "title":
						this.handleInput();
						this.updateFauxGates(elapsed);
						this.render();
						break;

					case "credits":
						this.handleInput();
						this.render();
						break;

					case "intro_cinematic":
						this.handleInput();
						this.updateIntroCinematic(elapsed);
						this.updateFauxGates(elapsed);
						this.render();
						break;

					// The game!
					case "running":
						if (this.wonGame) {
							this.updateWonGame(elapsed);
						} else {
							this.handleInput();
						}
						if (!this.paused) {
							this.updateWaves(elapsed);
							this.updateSpawnPoints(elapsed);
							this.updateClouds(elapsed);
							this.updateObjects(elapsed);
							this.updateFauxGates(elapsed);
							this.updateWeaponPickup(elapsed);
							this.updateCoinPickup(elapsed);
						}
						if (this.showTutorial) {
							this.updateTutorial(elapsed);
						}
						this.render();
						break;

					case "game_over":
						this.updateGameOver(elapsed);
						this.render();
						break;

					case "buy_now":
						this.handleInput();
						this.render();
						break;

				}

				if (!this.hideReticleTimer) {
					this.hideReticleTimer = new horde.Timer();
				}
				if (this.mouse.hasMoved) {
					this.showReticle = true;
					this.hideReticleTimer.start(5000);
					this.nextTutorial(3);
				}
				this.hideReticleTimer.update(elapsed);
				if (this.hideReticleTimer.expired()) {
					this.showReticle = false;
				}

				this.mouse.hasMoved = false;

				this.requestFrame();
			};

			proto.requestFrame = function () {
				if (!this.running) { return; }
				requestAnimationFrame(bind(this, this.update));
			};

			proto.updateWeaponPickup = function horde_Engine_proto_updateWeaponPickup (elapsed) {
				var w = this.weaponPickup;
				if (w.state === "on") {
					w.scale += ((4.5 / 1000) * elapsed);
					w.alpha -= ((2.5 / 1000) * elapsed);
					if (w.alpha <= 0) {
						w.state = "off";
					}
				}
			};

			proto.updateCoinPickup = function horde_Engine_proto_updateCoinPickup (elapsed) {
				var w = this.coinPickup;
				if (w.state === "on") {
					w.position.y -= ((50 / 1000) * elapsed);
					w.alpha -= ((0.7 / 1000) * elapsed);
					if (w.alpha <= 0) {
						w.state = "off";
					}
				}
			};

			proto.updateWonGame = function horde_Engine_proto_updateWonGame (elapsed) {

				var player = this.getPlayerObject();

				if (this.roseTimer) {
					this.roseTimer.update(elapsed);
				}

				switch (this.wonGamePhase) {

					// Move Xam to the center of the room
					case 0:
						var center = new horde.Vector2(304, 192);
						player.moveToward(center);
						var diff = player.position.clone().subtract(center).abs();
						if (diff.x <= 5 && diff.y <= 5) {
							this.wonGamePhase++;
						}
						break;

					case 1:
						player.setDirection(new horde.Vector2(0, 1));
						player.stopMoving();
						player.addState(horde.Object.states.VICTORIOUS);
						this.roseTimer = new horde.Timer();
						this.roseTimer.start(100);
						this.rosesThrown = 0;
						this.wonGamePhase++;
						break;

					case 2:
						if (this.roseTimer.expired()) {
							++this.rosesThrown;
							var rose = horde.makeObject("rose");
							if (horde.randomRange(1, 2) === 2) {
								rose.position.x = -32;
								rose.position.y = horde.randomRange(100, 300);
								rose.setDirection(new horde.Vector2(1, 0));
							} else {
								rose.position.x = 682;
								rose.position.y = horde.randomRange(100, 300);
								rose.setDirection(new horde.Vector2(-1, 0));
							}
							this.addObject(rose);
							this.roseTimer.reset();
						}
						if (this.rosesThrown > 100) {
							this.endGame();
						}
						break;

				}

			};

			proto.updateClouds = function horde_Engine_proto_updateClouds (elapsed) {

				if (this.enableClouds !== true) {
					return;
				}

				if (this.cloudTimer === null) {
					this.cloudTimer = new horde.Timer();
					this.cloudTimer.start(2000);
				}

				this.cloudTimer.update(elapsed);

				var clouds = 0;

				// Kill off clouds that are past the screen
				for (var id in this.objects) {
					var o = this.objects[id];
					if (o.type === "cloud") {
						clouds++;
						if (o.position.x < -(o.size.width)) {
							o.die();
						}
					}
				}

				// Spawn new clouds
				if (clouds < 10 && this.cloudTimer.expired()) {
					if (horde.randomRange(1, 10) >= 1) {
						var numClouds = horde.randomRange(1, 3);
						for (var x = 0; x < numClouds; x++) {
							var cloud = horde.makeObject("cloud");
							cloud.position.x = SCREEN_WIDTH + horde.randomRange(1, 32);
							cloud.position.y = horde.randomRange(
								-(cloud.size.height / 2),
								SCREEN_HEIGHT + (cloud.size.height / 2)
							);
							cloud.setDirection(new horde.Vector2(-1, 0));
							this.addObject(cloud);
						}
					}
					this.cloudTimer.reset();
				}

			};

			/**
			 * Updates the spawn points
			 * @param {number} elapsed Elapsed time in milliseconds since last update
			 * @return {void}
			 */
			proto.updateSpawnPoints = function horde_Engine_proto_updateSpawnPoints (elapsed) {
				if (this.gateState !== "up") {
					return;
				}
				var closeGates = true;
				// Iterate over the spawn points and update them
				for (var x in this.spawnPoints) {
					if (this.spawnPoints[x].queue.length >= 1) {
						closeGates = false;
					}
					// Spawn points can return an object to spawn
					var o = this.spawnPoints[x].update(elapsed, (this.monstersAlive === 0));
					if (o !== false) {
						// We need to spawn an object
						this.addObject(o);
					}
				}
				if (closeGates && !this.monstersAboveGates) {
					this.closeGates();
				}
			};

			proto.spawnWaveExtras = function horde_Engine_proto_spawnWaveExtras (waveNumber) {
				switch (waveNumber) {

					case 1:
						// Spawn a couple weapons scrolls to give the player an early taste of the fun!
						var player = this.getPlayerObject();

						// 1. Knife
						var wep = horde.makeObject("item_weapon_knife");
						wep.position = player.position.clone();
						wep.position.x -= 96;
						wep.position.y += 64;
						this.addObject(wep);

						// 2. Spear
						var wep = horde.makeObject("item_weapon_spear");
						wep.position = player.position.clone();
						wep.position.x -= 32;
						wep.position.y += 64;
						this.addObject(wep);

						// 3. Axe
						var wep = horde.makeObject("item_weapon_axe");
						wep.position = player.position.clone();
						wep.position.x += 32;
						wep.position.y += 64;
						this.addObject(wep);

						// 4. Fire
						var wep = horde.makeObject("item_weapon_fireball");
						wep.position = player.position.clone();
						wep.position.x += 96;
						wep.position.y += 64;
						this.addObject(wep);

						break;

					case 11:
						// Two spikes in the middle to the left and right
						var locs = [
							{x: 192, y: 224},
							{x: 416, y: 224}
						];
						var len = locs.length;
						for (var x = 0; x < len; ++x) {
							var pos = locs[x];
							var s = horde.makeObject("spikes");
							s.position = new horde.Vector2(pos.x, pos.y);
							this.addObject(s);
						}
						break;

					case 21:
						// Spike sentries in each corner
						var spikeLocs = [
							{x: 32, y: 64},
							{x: 32, y: 352},
							{x: 576, y: 64},
							{x: 576, y: 352}
						];
						var len = spikeLocs.length;
						for (var x = 0; x < len; x++) {
							var pos = spikeLocs[x];
							var s = horde.makeObject("spike_sentry");
							s.position = new horde.Vector2(pos.x, pos.y);
							this.addObject(s);
						}
						break;

					case 31:
						// Two spikes in the middle above and below
						var locs = [
							{x: 304, y: 114},
							{x: 304, y: 304}
						];
						var len = locs.length;
						for (var x = 0; x < len; ++x) {
							var pos = locs[x];
							var s = horde.makeObject("spikes");
							s.position = new horde.Vector2(pos.x, pos.y);
							this.addObject(s);
						}
						break;

					case 41:
						this.enableClouds = true;
						break;

					case 50:
						// Despawn all traps; Doppelganger is hard enough!!
						for (var id in this.objects) {
							var obj = this.objects[id];
							if (obj.role === "trap") {
								obj.die();
							}
						}
						break;

				}
			};

			/**
			 * Updates the waves
			 * @param {number} elapsed Elapsed time in milliseconds since last update
			 * @return {void}
			 */
			proto.updateWaves = function horde_Engine_proto_updateWaves (elapsed) {
				if (this.wonGame) {
					return;
				}
				this.waveTimer.update(elapsed);
				var spawnsEmpty = true;
				for (var x in this.spawnPoints) {
					if (this.spawnPoints[x].queue.length > 0) {
						spawnsEmpty = false;
					}
				}
				// If the spawns are empty AND there are no monsters alive
				if (spawnsEmpty === true && this.monstersAlive === 0) {
					if (this.currentWaveId === (this.waves.length - 1)) {
						// Player won the game!!
						this.wonGame = true;
						horde.sound.stop("normal_battle_music");
						horde.sound.stop("final_battle_music");
						horde.sound.play("victory");
						return;
					}

					// Clay.io: Achievements
					var achievementId = false;
					switch( this.currentWaveId + 1 ) {
						case 1:
							achievementId = "wave1";
							break;
						case 5:
							achievementId = "wave5";
							break;
					}

			/* 		if(achievementId && !horde.achievementsGranted[achievementId]) {
						horde.achievementsGranted[achievementId] = true; // so we don't keep sending to Clay.io
						(new Clay.Achievement({ id: achievementId })).award();
					} */

					this.currentWaveId++;
					var actualWave = (this.currentWaveId + 1);
					if (this.continuing || this.waveHack) {
						var start = (this.waveHack) ? 1 : 2;
						// Start with 2 as we don't want the bonus weapons spawning at continue
						for (var wn = start; wn <= actualWave; ++wn) {
							this.spawnWaveExtras(wn);
						}
						this.waveHack = false;
					} else {
						this.spawnWaveExtras(actualWave);
					}
					var waveTextString = "Wave " + actualWave;
					var waveMusic = "normal_battle_music";
					if (actualWave > 1) {
						this.putData("checkpoint_wave", this.currentWaveId);
						this.putData("checkpoint_hero", JSON.stringify(this.getPlayerObject()));
					}
					if (this.waves[this.currentWaveId].bossWave) {
						waveTextString = ("Boss: " + this.waves[this.currentWaveId].bossName) + "!";
						waveMusic = "final_battle_music";
					}

					if (this.currentMusic !== waveMusic) {
						horde.sound.stop(this.currentMusic);
						this.currentMusic = waveMusic;
						horde.sound.play(this.currentMusic);
					}

					this.initSpawnWave(this.waves[this.currentWaveId]);
					this.waveText.string = waveTextString;
					this.waveText.alpha = 0;
					this.waveText.size = 1;
					this.waveText.state = "init";

					// Initialize the waveText buffer
					var b = this.canvases.waveText.getContext("2d");
					var text = this.waveText.string;

					b.clearRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

					b.save();
					b.font = ("Bold " + WAVE_TEXT_HEIGHT + "px MedievalSharp");
					b.lineWidth = 3;
					b.textBaseline = "top";
					b.strokeStyle = COLOR_BLACK;
					b.fillStyle = "rgb(230, 103, 8)";

					b.strokeText(text, 0, 0);
					b.fillText(text, 0, 0);

					var metrics = b.measureText(text);
					this.waveText.width = metrics.width;
					b.restore();

					this.continuing = false;
				}
				switch (this.waveText.state) {
					case "init":
						this.waveText.alpha += ((2 / 1000) * elapsed);
						if (this.waveText.alpha >= 1) {
							this.waveText.alpha = 1;
							this.waveText.timer = new horde.Timer();
							this.waveText.timer.start(250);
							this.waveText.state = "display";
						}
						break;
					case "display":
						this.waveText.timer.update(elapsed);
						if (this.waveText.timer.expired()) {
							this.waveText.state = "hide";
						}
						break;
					case "hide":
						// hide the text
						this.waveText.alpha -= ((1.5 / 1000) * elapsed);
						this.waveText.size += ((20 / 1000) * elapsed);
						if (this.waveText.alpha <= 0) {
							this.waveText.alpha = 0;
							this.waveText.state = "off";
						}
						break;
				}
			};

			proto.updateGameOver = function horde_Engine_proto_updateGameOver (elapsed) {

				if (!this.gameOverAlpha) {
					this.gameOverReady = false;
					this.gameOverAlpha = 0;
				}

				var alphaChange = ((0.2 / 1000) * elapsed);
				this.gameOverAlpha += Number(alphaChange) || 0;

				if (this.gameOverAlpha >= 0.75) {
					this.gameOverReady = true;
					this.gameOverAlpha = 0.75;
				}

				if (this.gameOverReady) {
					if (!this.statsTimer) {
						this.statsTimer = new horde.Timer();
						this.statsCount = 0;
						this.statsIndex = 0;
						// Settings for Wave reached:
						this.statsTimer.start(50);
						this.statsIncrement = 1;
					}
					this.statsTimer.update(elapsed);
					if (this.statsTimer.expired()) {
						this.statsTimer.reset();
						this.statsCount += this.statsIncrement;
					}
				}

				if ((this.statsIndex >= 4) && !this.highScoreSaved) {
					this.highScoreSaved = true;

					var highScore = Number(this.getData(HIGH_SCORE_KEY));
					var totalScore = this.getTotalScore();

					// Clay.io: Post score to clay.io
					var _this = this;
			/* 		this.clayLeaderboard.post({ score: totalScore }, function() {
						// Show the leaderboard
						_this.showLeaderboard(true);
					}); */

					if (totalScore > highScore) {
						this.putData(HIGH_SCORE_KEY, totalScore);
						horde.sound.play("victory");
						this.gotNewHighScore = true;
					}
				}

			};

			/**
			* Displays the Clay.io leaderboard
			* @param {Boolean} share If true, will give the player an option to share their score
			*/
			proto.showLeaderboard = function horde_Engine_proto_showLeaderboard (share) {
				var share = typeof share === 'undefined' ? false : share;

				var html = []; // Post to social HTML. Array for readability
				html.push("Share your score: " );
				html.push("<a href='#' id='facebook-button'>Facebook</a>" );
				html.push(" or <a href='#' id='twitter-button'>Twitter</a>" );
				var _this = this;
				if( share ) {
					this.clayLeaderboard.show({ html: html.join("") }, function() {
						document.getElementById('facebook-button').onclick = function() {
							_this.postSocial('facebook');
						}
						document.getElementById('twitter-button').onclick = function() {
							_this.postSocial('twitter');
						}
					});
				}
				else {
					this.clayLeaderboard.show();
				}
			}

			/**
			* Takes a screenshot and posts it to the specified site through Clay.io
			* @param {String} site facebook or twitter
			*/
			proto.postSocial = function horde_Engine_proto_postSocial (site) {
				var screenshot = new Clay.Screenshot({ prompt: false, id: 'display' });
				var _this = this;
				screenshot.save(function( response ) {
					if(site == 'facebook')
						(new Clay.Facebook()).post({ message: "I just scored " + _this.getTotalScore() + " in Onslaught! Arena - (screenshot: " + response.url + ")", link: "http://onslaughtarena.clay.io" });
					else if(site == 'twitter')
						(new Clay.Twitter()).post({ message: "I just scored " + _this.getTotalScore() + " in Onslaught! Arena - (sreenshot: " + response.url + ")! Play me: http://onslaughtarena.clay.io" });
				} );

			}

			proto.openGates = function horde_Engine_proto_openGates () {
				if (this.gateState !== "up") {
					this.gateDirection = "up";
					horde.sound.play("gate_opens");
				}
			};

			proto.closeGates = function horde_Engine_proto_closeGates () {
				if (this.gateState !== "down") {
					this.gateDirection = "down";
					horde.sound.play("gate_closes");
				}
			};

			proto.updateFauxGates = function horde_Engine_proto_updateFauxGates (elapsed) {

				if (this.gateDirection === "down") {
					this.gatesX = 0;
					this.gatesY += ((200 / 1000) * elapsed);
					if (this.gatesY >= 0) {
						this.gatesX = 0;
						this.gatesY = 0;
						this.gateDirection = "";
						this.gateState = "down";
					}
				}

				if (this.gateDirection === "up") {
					this.gatesX = horde.randomRange(-1, 1);
					this.gatesY -= ((50 / 1000) * elapsed);
					if (this.gatesY <= -54) {
						this.gatesX = 0;
						this.gatesY = -54;
						this.gateDirection = "";
						this.gateState = "up";
					}
				}

			};

			proto.updateTutorial = function horde_Engine_proto_updateTutorial (elapsed) {

				var speed = 0.1;

				if (this.tutorialDirection === "down") {
					this.tutorialY += (speed * elapsed);
					if (this.tutorialY >= 0) {
						this.tutorialY = 0;
						this.tutorialDirection = null;

						if (this.tutorialIndex >= TUTORIAL_NUM_TIPS) {
							this.hideTutorialTimer.start(5000);
						}
					}
				}

				if (this.tutorialDirection === "up") {
					this.tutorialY -= (speed * elapsed);
					if (this.tutorialY < -TUTORIAL_HEIGHT) {
						this.tutorialY = -TUTORIAL_HEIGHT;
						this.tutorialDirection = "down";
						this.tutorialIndex += 1;
						if (this.tutorialIndex > TUTORIAL_NUM_TIPS) {
							this.showTutorial = false;
						}
					}
				}

				if (!this.hideTutorialTimer) {
					this.hideTutorialTimer = new horde.Timer();
				}

				if (!this.nextTutorialTimer) {
					this.nextTutorialTimer = new horde.Timer();
					this.nextTutorialTimer.start(10000);
				}

				this.hideTutorialTimer.update(elapsed);
				this.nextTutorialTimer.update(elapsed);

				if (this.hideTutorialTimer.expired()) {
					this.tutorialDirection = "up";
				}

				if (this.nextTutorialTimer.expired()) {
					this.nextTutorial(this.tutorialIndex + 1);
					this.nextTutorialTimer.reset();
				}

			};

			proto.nextTutorial = function horde_Engine_proto_nextTutorial (index) {

				if (!this.showTutorial || (this.tutorialDirection !== null)) {
					return;
				}

				// Move the tutorial up if we want to see the next one
				if (this.tutorialIndex === (index - 1)) {
					this.tutorialDirection = "up";
				}

			};

			/**
			* Returns an array of tiles which intersect a given rectangle
			* @param {horde.Rect} rect Rectangle
			* @return {array} Array of tiles
			*/
			proto.getTilesByRect = function horde_Engine_proto_getTilesByRect (rect) {

				var tiles = [];

				var origin = new horde.Vector2(rect.left, rect.top);
				var size = new horde.Vector2(rect.width, rect.height);

				var begin = origin.clone().scale(1 / this.tileSize.width).floor();
				var end = origin.clone().add(size).scale(1 / this.tileSize.width).floor();

				for (var tx = begin.x; tx <= end.x; tx++) {
					for (var ty = begin.y; ty <= end.y; ty++) {
						tiles.push({
							x: tx,
							y: ty
						});
					}
				}

				return tiles;

			};

			/**
			* Checks if a given object is colliding with any tiles
			* @param {horde.Object} object Object to check
			* @return {boolean} True if object is colliding with tiles, otherwise false
			*/
			proto.checkTileCollision = function horde_Engine_proto_checkTileCollision (object) {

				var tilesToCheck = this.getTilesByRect(object.boundingBox());

				for (var i = 0, len = tilesToCheck.length; i < len; i++) {
					var t = tilesToCheck[i];
					if (this.map[t.y] && this.map[t.y][t.x] === 0) {
						// COLLISION!
						return t;
					}
				}

				// No tile collision
				return false;

			};

			proto.moveObject = function horde_Engine_proto_moveObject (object, elapsed) {

				if (!object.badass && object.hasState(horde.Object.states.HURTING)) {
					return false;
				}

				var speed = object.speed;
				if (object.hasState(horde.Object.states.SLOWED)) {
					speed *= 0.20;
				}

				var px = ((speed / 1000) * elapsed);

				var axis = [];
				var collisionX = false;
				var collisionY = false;

				// Check tile collision for X axis
				if (object.direction.x !== 0) {
					// the object is moving along the "x" axis
					object.position.x += (object.direction.x * px);
					if (object.collidable) {
						if (object.position.x < 16) {
							object.position.x = 16;
						}
						if ((object.position.x + object.size.width) > 624) {
							object.position.x = (624 - object.size.width);
						}
						var tile = this.checkTileCollision(object);
						if (tile !== false) {
							axis.push("x");
							collisionX = true;
							var objCenterX = (object.position.x + (object.size.width / 2));
							var tileCenterX = ((tile.x * this.tileSize.width) + (this.tileSize.width / 2));
							if (objCenterX < tileCenterX) {
								object.position.x = tile.x * this.tileSize.width - object.size.width;
							} else {
								object.position.x = tile.x * this.tileSize.width + this.tileSize.width;
							}
						}
					}
				}

				// Check tile collision for Y axis
				if (object.direction.y !== 0) {
					// the object is moving along the "y" axis
					object.position.y += (object.direction.y * px);
					if (object.collidable) {
						if ((object.position.y + object.size.height) > 400) {
							object.position.y = (400 - object.size.height);
						}
						var tile = this.checkTileCollision(object);
						if (tile !== false) {
							axis.push("y");
							collisionY = true;
							var objCenterY = (object.position.y + (object.size.height / 2));
							var tileCenterY = ((tile.y * this.tileSize.height) + (this.tileSize.height / 2));
							if (objCenterY < tileCenterY) {
								object.position.y = tile.y * this.tileSize.height - object.size.height;
							} else {
								object.position.y = tile.y * this.tileSize.height + this.tileSize.height;
							}
						}
					}
				}

				if (object.collidable) {

					var yStop = 0;
					if (
						this.gateState === "down"
						|| object.role === "monster"
						|| object.role === "hero"
					) {
						yStop = GATE_CUTOFF_Y;
					}

					if (object.direction.y < 0 && object.position.y < yStop) {
						object.position.y = yStop;
						axis.push("y");
					}

					if (axis.length > 0) {
						object.wallCollide(axis);
					}

				}

			};

			proto.dropObject = function horde_Engine_proto_dropObject (object, type) {
				var drop = horde.makeObject(type);
				drop.position = object.position.clone();
				drop.position.y -= 1;
				if (this.isSpecialLoot(type)) {
					drop.position = new horde.Vector2(304, 226);
				}
				this.addObject(drop);
				if (this.isSpecialLoot(type)) {
					// Also spawn the pointer
					var ptr = horde.makeObject("pickup_arrow");
					ptr.position = drop.position.clone();
					ptr.position.x = (320 - (ptr.size.width / 2));
					ptr.position.y -= (ptr.size.height + 10);
					this.addObject(ptr);
				}
			};

			proto.isSpecialLoot = function horde_Engine_proto_isSpecialLoot (type) {
				return (
					(type === "item_weapon_fire_sword")
					|| (type === "item_gold_chest")
				);
			};

			proto.spawnLoot = function horde_Engine_proto_spawnLoot (object) {

				// Don't spawn stuff out of reach
				if (object.position.y < 44) return;

				var table = object.lootTable;
				var len = table.length;

				var weightedTable = [];
				for (var x = 0; x < len; x++) {
					var entry = table[x];
					for (var j = 0; j < entry.weight; j++) {
						weightedTable.push(entry.type);
					}
				}

				var rand = horde.randomRange(0, weightedTable.length - 1);
				var type = weightedTable[rand];

				if (type !== null) {
					var player = this.getPlayerObject();
					if (type === "item_food" && player.wounds === 0) {
						type = "item_chest";
					}
					if (type === "WEAPON_DROP") {
						switch (horde.randomRange(1, 4)) {
							case 1: type = "item_weapon_knife"; break;
							case 2: type = "item_weapon_spear"; break;
							case 3: type = "item_weapon_fireball"; break;
							case 4: type = "item_weapon_axe"; break;
						}
					}
					if (
						type.indexOf("item_weapon") >= 0
						&& player.hasWeapon("h_fire_sword")
					) {
						type = "item_chest";
					}
					this.dropObject(object, type);
				}

			};

			proto.updateObjects = function (elapsed) {

				var numMonsters = 0;
				var numMonstersAboveGate = 0;

				for (var id in this.objects) {

					var o = this.objects[id];

					if (o.isDead()) {
						if (o.role === "hero") {
							this.endGame();
							return;
						}
						o.execute("onDelete", [this]);
						delete(this.objects[o.id]);
						continue;
					}

					if (o.role === "monster" || o.type === "pickup_arrow") {
						numMonsters++;
						if (o.position.y <= GATE_CUTOFF_Y) {
							numMonstersAboveGate++;
						}
					}

					var action = o.update(elapsed, this);
					switch (action) {
						case "shoot":
							this.objectAttack(o);
							break;
					}

					if (o.isMoving() && !o.hasState(horde.Object.states.STUNNED)) {
						this.moveObject(o, elapsed);
					}

					if (
						o.role === "fluff"
						|| o.role === "powerup_food"
						|| o.hasState(horde.Object.states.DYING)
						|| o.hasState(horde.Object.states.INVISIBLE)
					) {
						continue;
					}

					for (var x in this.objects) {
						var o2 = this.objects[x];
						if (
							o2.isDead()
							|| o2.team === o.team
							|| o2.role === "fluff"
							|| o2.hasState(horde.Object.states.DYING)
							|| o2.hasState(horde.Object.states.INVISIBLE)
						) {
							continue;
						}
						// Reduce the size of the bounding boxes a tad when evaluating object => object collision
						if (o.boundingBox().reduce(5).intersects(o2.boundingBox().reduce(5))) {
							if (o.role == "hero") {
								if (o2.role == "powerup_food") {
									o2.die();
									o.wounds -= o2.healAmount;
									if (o.wounds < 0) o.wounds = 0;
									o.meatEaten++;
									horde.sound.play("eat_food");
									for (var j = 0; j < 5; ++j) {
										var heart = horde.makeObject("mini_heart");
										heart.position.x = (o.position.x + (j * (o.size.width / 5)));
										heart.position.y = (o.position.y + o.size.height - horde.randomRange(0, o.size.height));
										this.addObject(heart);
									}
								} else if (o2.role == "powerup_coin") {
									o2.die();
									o.gold += o2.coinAmount;
									horde.sound.play("coins");

									var c = this.coinPickup;
									c.amount = o2.coinAmount;
									c.y = 0;
									c.alpha = 1;
									c.position = o2.position.clone();
									c.state = "on";

									if (this.isSpecialLoot(o2.type)) {
										for (var j in this.objects) {
											if (this.objects[j].type === "pickup_arrow") {
												this.objects[j].die();
											}
										}
									}
								} else if (o2.role == "powerup_weapon") {
									o2.die();
									o.addWeapon(o2.wepType, o2.wepCount);
									horde.sound.play("pickup_weapon");

									var w = this.weaponPickup;
									w.type = o2.type;
									w.scale = 1;
									w.alpha = 0.9;
									w.position = o2.position.clone();
									w.state = "on";

									if (this.isSpecialLoot(o2.type)) {
										for (var j in this.objects) {
											if (this.objects[j].type === "pickup_arrow") {
												this.objects[j].die();
											}
										}
									}
								}
							}
							if (
								o.team !== null
								&& o2.team !== null
								&& o.team !== o2.team
							) {
								this.dealDamage(o2, o);
								this.dealDamage(o, o2);
							}
						}

					}

					// Update glowing weapons
					if (this.isBadassWeapon(o)) {
						if (o.glow === undefined) {
							o.glow = {
								alpha: 0,
								increment: GLOW_INCREMENT,
								timer: new horde.Timer()
							};
							o.glow.timer.start(50);
						}

						o.glow.timer.update(elapsed);

						if (o.glow.timer.expired()) {
							o.glow.timer.reset();
							o.glow.alpha += o.glow.increment;

							var max = (1 - GLOW_INCREMENT);
							if (o.glow.alpha >= max) {
								o.glow.alpha = max;
								o.glow.increment = -GLOW_INCREMENT;
							}

							var min = GLOW_INCREMENT;
							if (o.glow.alpha <= min) {
								o.glow.alpha = min;
								o.glow.increment = GLOW_INCREMENT;
							}
						}
					}

				}

				this.monstersAlive = numMonsters;
				this.monstersAboveGates = (numMonstersAboveGate > 0);

				var player = this.getPlayerObject();
				if (this.woundsTo < player.wounds) {
					this.woundsTo += ((this.woundsToSpeed / 1000) * elapsed);
				} else if (this.woundsTo > player.wounds) {
					this.woundsTo -= ((this.woundsToSpeed / 1000) * elapsed);
				} else {
					this.woundsTo = player.wounds;
				}

				var totalScore = this.getTotalScore();
				var diff = Math.abs(this.scoreCount - totalScore);
				var speed = horde.clamp(diff, 1000, 10000);
				var amount = Math.floor((speed / 1000) * elapsed);
				if (this.scoreCount < totalScore) {
					this.scoreCount += amount;
					if (this.scoreCount > totalScore) this.scoreCount = totalScore;
				} else if (this.scoreCount > totalScore) {
					this.scoreCount -= amount;
					if (this.scoreCount < totalScore) this.scoreCount = totalScore;
				}

				// Snap to grid to prevent vibrating bars
				if (Math.abs(player.wounds - this.woundsTo) <= 1) {
					this.woundsTo = player.wounds
				}

			};

			// Deals damage from object "attacker" to "defender"
			proto.dealDamage = function (attacker, defender) {

				// Monsters don't damage projectiles
				if (attacker.role === "monster" && defender.role === "projectile") {
					return false;
				}

				// Allow the objects to handle the collision
				attacker.execute("onObjectCollide", [defender, this]);

				// Traps & Projectiles shouldn't damage each other
				if (
					(attacker.role == "projectile" && defender.role == "trap")
					|| (attacker.role == "trap" && defender.role == "projectile")
				) {
					return false;
				}

				// Allow the defender to declare themselves immune to attacks from the attacker
				// For example: Cube is immune to non-fire attacks
				var nullify = defender.execute("onThreat", [attacker, this]);

				// Check for defender immunity
				if (
					defender.hasState(horde.Object.states.INVINCIBLE)
					|| defender.hitPoints === Infinity
					|| nullify === true
				) {
					// Defender is immune/invincible
					if (
						attacker.role === "projectile"
						&& attacker.hitPoints !== Infinity
					) {
						if (
							(
								defender.damageType === "magic"
								|| defender.damageType === "physical"
							)
							&& attacker.damageType === "physical"
						) {
							// deflect if both parties are physical
							attacker.reverseDirection();
							attacker.deflect();
							horde.sound.play("immunity");
						} else {
							// otherwise just kill the attacker
							attacker.die();
						}
					}
					return false;
				}

				// Special case for non-immune projectiles hitting each other
				if (
					attacker.hitPoints !== Infinity
					&& attacker.role === "projectile"
					&& defender.role === "projectile"
					&& attacker.damageType === "physical"
					&& defender.damageType === "physical"
				) {
					if (attacker.piercing === false) {
						attacker.reverseDirection();
						attacker.deflect();
					}
					if (defender.piercing === false) {
						defender.reverseDirection();
						defender.deflect();
					}
					return false;
				}

				// Allow attackers to do stuff when they've hurt something
				attacker.execute("onDamage", [defender, this]);

				// Track combat stats
				var scorer = attacker;
				if (scorer.ownerId !== null) {
					var owner = this.objects[scorer.ownerId];
					if (owner) {
						scorer = owner;
					}
				}
				if (attacker.role === "projectile") {
					scorer.shotsLanded++;
				}

				// Deal damage and check for death
				if (defender.wound(attacker.damage)) {
					// defender has died

					// Assign gold/kills etc
					scorer.gold += defender.worth;
					scorer.kills++;
					defender.execute("onKilled", [attacker, this]);
					if (defender.lootTable.length > 0) {
						this.spawnLoot(defender);
					}

					// Handler piercing weapons
					if (
						attacker.role === "projectile"
						&& attacker.piercing === false
						&& attacker.hitPoints !== Infinity
					) {
						attacker.die();
					}

				} else {
					// defender did NOT die

					// Make the player invincible after some damage
					if (attacker.damage > 0 && defender.role === "hero") {
						defender.addState(horde.Object.states.INVINCIBLE, 2500);
					}

					// Projectile failed to kill it's target; automatic death for projectile
					if (attacker.role === "projectile" && attacker.hitPoints !== Infinity) {
						attacker.die();
					}

				}

			};

			/**
			* Updates the targeting reticle position based on mouse input
			* @return {void}
			*/
			proto.updateTargetReticle = function horde_Engine_proto_updateTargetReticle () {

				this.targetReticle.moving = false;

				// Grab the current mouse position as a vector
				var mouseV = new horde.Vector2(this.mouse.mouseX, this.mouse.mouseY);

				// Keep the targeting reticle inside of the play area
				// NOTE: This will need to be updated if the non-blocked map area changes
				var mouseBounds = new horde.Rect(
					32, 64, SCREEN_WIDTH - 64, SCREEN_HEIGHT - 160
				);

				var trp = this.targetReticle.position;

				if (trp.x !== mouseV.x && trp.y !== mouseV.y) {
					this.targetReticle.moving = true;
					var diff = trp.clone().subtract(mouseV.clone()).abs();
					var speed = horde.clamp((diff.x + diff.y) * 2, 1, 100);
					this.targetReticle.angle += ((speed / 1000) * this.lastElapsed);
					if (this.targetReticle.angle > (Math.PI * 2)) {
						this.targetReticle.angle = 0;
					}
				}

				// Adjust the X position
				if (mouseV.x < mouseBounds.left) {
					trp.x = mouseBounds.left;
				} else if (mouseV.x > mouseBounds.left + mouseBounds.width) {
					trp.x = mouseBounds.left + mouseBounds.width;
				} else {
					trp.x = mouseV.x;
				}

				// Adjust the Y position
				if (mouseV.y < mouseBounds.top) {
					trp.y = mouseBounds.top;
				} else if (mouseV.y > mouseBounds.top + mouseBounds.height) {
					trp.y = mouseBounds.top + mouseBounds.height;
				} else {
					trp.y = mouseV.y;
				}

			};

			/**
			* Grabs the data for where to continue the game
			*/
			proto.grabContinueInfo = function horde_Engine_proto_grabContinueInfo () {
				var _this = this;
				this.getData("checkpoint_wave", function(response) {
					var checkpointWave = response.data;
					if (checkpointWave !== null && typeof checkpointWave !== 'undefined') {
						// Checkpoint data exists
						_this.currentWaveId = (checkpointWave - 1);
						_this.getData("checkpoint_hero", function(response) {
							var checkpointHero = response.data;
							if (checkpointHero !== null) {
								var player = _this.getPlayerObject();
								player.load(checkpointHero);
								// Start the player at full life but ding him for the amount of wounds he had
								player.totalDamageTaken += player.wounds;
								player.wounds = 0;
							}
							_this.continuing = true;
							_this.showTutorial = false;
							_this.state = "intro_cinematic";
						});
					}
				}, true);
			}

			/**
			* Handles game input
			* @return {void}
			*/
			proto.handleInput = function horde_Engine_proto_handleInput () {

				var kb = this.keyboard;
				var keys = horde.Keyboard.Keys;
				var buttons = horde.Mouse.Buttons;
				var mouseV = new horde.Vector2(this.mouse.mouseX, this.mouse.mouseY);
				var newPointerY;
				var usingPointerOptions = false;

				this.leaderboardHover = this.achievementsHover = this.loginHover = false;

				if (this.state == "running") {

					// ESC to skip tutorial.
					if (this.keyboard.isKeyPressed(keys.ESCAPE)) {
						if (this.showTutorial) {
							this.tutorialIndex = TUTORIAL_NUM_TIPS;
							this.nextTutorial(TUTORIAL_NUM_TIPS + 1);
							return;
						}
					}

					// Press "p" to pause.
					if (this.keyboard.isKeyPressed(keys.P) || this.keyboard.isKeyPressed(keys.ESCAPE)) {
						this.togglePause();
						this.keyboard.clearKeys();
						return;
					}

					if (this.paused) {
						usingPointerOptions = true;
					}

					// Toggle sound with "M" for "mute".
					if (this.canMute && this.keyboard.isKeyPressed(77)) {
						horde.sound.toggleMuted();
					}

					// Toggle fullscreen with "F".
					if (this.canFullscreen && this.keyboard.isKeyPressed(70)) {
						this.toggleFullscreen();
					}

					// Toggle keyboard controls with "K".
					if (this.keyboard.isKeyPressed(75)) {
						this.wasdMovesArrowsAttack = !this.wasdMovesArrowsAttack;
					}

					// Code: html5 = HTML5 shield
					/*
					if (this.keyboard.historyMatch(horde.Keyboard.html5Code)) {
						var p = this.getPlayerObject();
						p.spriteY = 992;
					}
					*/

					if (!horde.isDemo()) {

						// Code: meat = Super Meat Boy mode
						if (this.keyboard.historyMatch(horde.Keyboard.meatboyCode)) {
							var p = this.getPlayerObject();
							p.isMeatboy = true;
							p.initMeatBoy();
						}

						// Code: lddqd = god mode
						if (this.keyboard.historyMatch(horde.Keyboard.godModeCode)) {
							this.keyboard.clearHistory();
							var p = this.getPlayerObject();
							p.cheater = true;
							if (p.hasState(horde.Object.states.INVINCIBLE)) {
								p.removeState(horde.Object.states.INVINCIBLE);
							} else {
								p.addState(horde.Object.states.INVINCIBLE);
							}
							horde.sound.play("code_entered");
						}

						// Code: ldkfa = Infinite fire swords
						if (this.keyboard.historyMatch(horde.Keyboard.allWeaponsCode)) {
							this.keyboard.clearHistory();
							var p = this.getPlayerObject();
							p.cheater = true;
							p.weapons = [{
								type: "h_fire_sword",
								count: null
							}];
							horde.sound.play("code_entered");
						}

						// Code: awesm = Infinite fire knives
						if (this.keyboard.historyMatch(horde.Keyboard.awesmCode)) {
							this.keyboard.clearHistory();
							var p = this.getPlayerObject();
							p.cheater = true;
							p.weapons = [{
								type: "h_fire_knife",
								count: null
							}];
							horde.sound.play("code_entered");
						}

						// Code: ldbomb = Infinite firebombs
						if (this.keyboard.historyMatch(horde.Keyboard.bombCode)) {
							this.keyboard.clearHistory();
							var p = this.getPlayerObject();
							p.cheater = true;
							p.weapons = [{
								type: "h_firebomb",
								count: null
							}];
							horde.sound.play("code_entered");
						}

						// Code: lddebug = toggle debug
						if (this.keyboard.historyMatch(horde.Keyboard.debugCode)) {
							this.keyboard.clearHistory();
							this.debug = !this.debug;
							horde.sound.play("code_entered");
						}

						// Code: ldreset = reset save data
						if (this.keyboard.historyMatch(horde.Keyboard.resetCode)) {
							this.keyboard.clearHistory();
							this.clearData("checkpoint_wave");
							this.clearData("checkpoint_hero");
							this.putData(HIGH_SCORE_KEY, DEFAULT_HIGH_SCORE);
							horde.sound.play("code_entered");
						}

						// Code: cyclops = play as the cyclops
						if (this.keyboard.historyMatch(horde.Keyboard.cyclopsCode)) {
							var p = this.getPlayerObject();

							if (!p.cheater) {
								horde.sound.play("code_entered");
								this.keyboard.clearHistory();

								p.cheater = true;
								p.hitPoints *= 2;
								p.size = new horde.Size(64, 64);
								p.spriteY = 224;
								p.weapons = [
									{type: "e_boulder", count: null}
								];
								p.wounds *= 2;
							}
						}

					} // end isDemo

					if (this.paused) {

						var startY = (this.pointerYStart - 22);

						if (this.verifyQuit) {
							// Nevermind
							if (
								(mouseV.x >= POINTER_X && mouseV.x <= (POINTER_X + 192))
								&& (mouseV.y > startY && mouseV.y < (startY + (POINTER_HEIGHT - 1)))
							) {
								if (this.mouse.hasMoved && this.pointerY !== 0) newPointerY = 0;
								if (this.mouse.isButtonDown(buttons.LEFT)) {
									this.keyboard.keyStates[keys.SPACE] = true;
								}
							}

							// Quit, seriously
							if (
								(mouseV.x >= POINTER_X && mouseV.x <= (POINTER_X + 192))
								&& (mouseV.y > (startY + POINTER_HEIGHT) && mouseV.y < ((startY + POINTER_HEIGHT) + 36))
							) {
								if (this.mouse.hasMoved && this.pointerY !== 1) newPointerY = 1;
								if (this.mouse.isButtonDown(buttons.LEFT)) {
									this.keyboard.keyStates[keys.SPACE] = true;
								}
							}
						} else {
							// Resume
							if (
								(mouseV.x >= POINTER_X && mouseV.x <= (POINTER_X + 106))
								&& (mouseV.y > startY && mouseV.y < (startY + (POINTER_HEIGHT - 1)))
							) {
								if (this.mouse.hasMoved && this.pointerY !== 0) newPointerY = 0;
								if (this.mouse.isButtonDown(buttons.LEFT)) {
									this.keyboard.keyStates[keys.SPACE] = true;
								}
							}

							// Quit
							if (
								(mouseV.x >= POINTER_X && mouseV.x <= (POINTER_X + 106))
								&& (mouseV.y > (startY + POINTER_HEIGHT) && mouseV.y < ((startY + POINTER_HEIGHT) + 36))
							) {
								if (this.mouse.hasMoved && this.pointerY !== 1) newPointerY = 1;
								if (this.mouse.isButtonDown(buttons.LEFT)) {
									this.keyboard.keyStates[keys.SPACE] = true;
								}
							}
						}

						if (kb.isKeyPressed(keys.ENTER) || kb.isKeyPressed(keys.SPACE)) {

							kb.clearKey(keys.ENTER);
							kb.clearKey(keys.SPACE);
							this.mouse.clearButtons();

							switch (this.pointerY) {
								case 0: // Resume
									this.togglePause();
									break;
								case 1: // Quit
									horde.sound.play("select_pointer");
									if (this.verifyQuit) {
										this.verifyQuit = false;
										this.togglePause();
										var p = this.getPlayerObject();
										p.wound(100);
									} else {
										this.pointerY = 0;
										this.verifyQuit = true;
									}
									break;
							}

						}
					}

				}

				if (this.state === "title") {

					usingPointerOptions = true;

					// Konami code! Hit Points *= 3
					if (!this.konamiEntered && this.keyboard.historyMatch(horde.Keyboard.konamiCode)) {
						horde.sound.play("code_entered");
						this.konamiEntered = true;
						var p = this.getPlayerObject();
						p.cheater = true;
						p.hitPoints *= 3;
					}

					// Accept hover/click with mouse on title screen options [#102]
					var startX = (POINTER_X - 40);
					var stopX = (POINTER_X + 130);
					var startY = (this.pointerYStart - 22);

					// Buy Now! or Continue
					if (horde.isDemo() || this.canContinue()) {
						if (
							(mouseV.x >= startX && mouseV.x <= stopX)
							&& (mouseV.y >= startY && mouseV.y < (startY + 20))
						) {
							if (this.mouse.hasMoved && this.pointerY !== 0) newPointerY = 0;
							if (this.mouse.isButtonDown(buttons.LEFT)) {
								this.keyboard.keyStates[keys.SPACE] = true;
							}
						}
					}

					// New game
					startY += POINTER_HEIGHT;
					if (
						(mouseV.x >= startX && mouseV.x <= stopX)
						&& (mouseV.y >= startY && mouseV.y < (startY + 20))
					) {
						if (this.mouse.hasMoved && this.pointerY !== 1) newPointerY = 1;
						if (this.mouse.isButtonDown(buttons.LEFT)) {
							this.keyboard.keyStates[keys.SPACE] = true;
						}
					}

					// Credits
					startY += POINTER_HEIGHT;
					if (
						(mouseV.x >= startX && mouseV.x <= stopX)
						&& (mouseV.y >= startY && mouseV.y < (startY + 20))
					) {
						if (this.mouse.hasMoved && this.pointerY !== 2) newPointerY = 2;
						if (this.mouse.isButtonDown(buttons.LEFT)) {
							this.keyboard.keyStates[keys.SPACE] = true;
						}
					}

					// Clay.io: High Scores
					startY = 444; // 444px from top
					if (
						(mouseV.x >= POINTER_X - 50 && mouseV.x <= POINTER_X + 50)
						&& (mouseV.y >= startY && mouseV.y < (startY + 18)) // 18 = height of button
					) {
						this.leaderboardHover = true;
						if (this.mouse.isButtonDown(buttons.LEFT)) {
							if(!this.leaderboardShowFlag) {
								this.leaderboardShowFlag = true; // So the LB only shows once (with a 1 second 'cooldown')
								this.showLeaderboard();
								var _this = this;
								setTimeout(function() {
									_this.leaderboardShowFlag = false;
								}, 1000);
							}
						}
					}
					/* // Clay.io: Achievements List
					if (
						(mouseV.x >= POINTER_X + 50 && mouseV.x <= POINTER_X + 150)
						&& (mouseV.y >= startY && mouseV.y < (startY + 20)) // 20 = height of button
					) {
						this.achievementsHover = true;
						if (this.mouse.isButtonDown(buttons.LEFT)) {
							if(!this.achievementsShowFlag) {
								this.achievementsShowFlag = true; // So the LB only shows once (with a 1 second 'cooldown')
								Clay.Achievement.showAll();
								var _this = this;
								setTimeout(function() {
									_this.achievementsShowFlag = false;
								}, 1000);
							}
						}
					}
					// Clay.io: Login
					startY += 20;
					if (
						!this.loggedIn
						&& (mouseV.x >= startX && mouseV.x <= stopX)
						&& (mouseV.y >= startY && mouseV.y < (startY + 18)) // 18 = height of button
					) {
						this.loginHover = true;
						if (this.mouse.isButtonDown(buttons.LEFT)) {
							if(!this.loginShowFlag) {
								this.loginShowFlag = true; // So the LB only shows once (with a 1 second 'cooldown')
								Clay.Player.login();
								var _this = this;
								setTimeout(function() {
									_this.loginShowFlag = false;
								}, 1000);
							}
						}
					}
			*/
					if (kb.isKeyPressed(keys.ENTER) || kb.isKeyPressed(keys.SPACE)) {

						horde.sound.play("select_pointer");
						kb.clearKey(keys.ENTER);
						kb.clearKey(keys.SPACE);
						this.mouse.clearButtons();

						switch (this.pointerY) {
							case 0:
								if (horde.isDemo()) {
									// Buy Now!
									location.href = URL_STORE;
								} else {
									// Continue
									this.grabContinueInfo();
								}
								break;
							case 1: // New game
								this.continuing = false;
								this.showTutorial = !this.touchMove;
								this.state = "intro_cinematic";
								break;
							case 2: // Credits
								this.state = "credits";
								break;
						}

					}

				}

				if (this.state == "buy_now") {

					usingPointerOptions = true;

					var startY = (this.pointerYStart - 22);

					// Buy Now!!
					if (
						(mouseV.x >= POINTER_X && mouseV.x <= (POINTER_X + 106))
						&& (mouseV.y > startY && mouseV.y < (startY + (POINTER_HEIGHT - 1)))
					) {
						if (this.mouse.hasMoved && this.pointerY !== 0) newPointerY = 0;
						if (this.mouse.isButtonDown(buttons.LEFT)) {
							this.keyboard.keyStates[keys.SPACE] = true;
						}
					}

					// Maybe later
					if (
						(mouseV.x >= POINTER_X && mouseV.x <= (POINTER_X + 106))
						&& (mouseV.y > (startY + POINTER_HEIGHT) && mouseV.y < ((startY + POINTER_HEIGHT) + 36))
					) {
						if (this.mouse.hasMoved && this.pointerY !== 1) newPointerY = 1;
						if (this.mouse.isButtonDown(buttons.LEFT)) {
							this.keyboard.keyStates[keys.SPACE] = true;
						}
					}

					if (kb.isKeyPressed(keys.ENTER) || kb.isKeyPressed(keys.SPACE)) {

						kb.clearKey(keys.ENTER);
						kb.clearKey(keys.SPACE);
						this.mouse.clearButtons();

						horde.sound.play("select_pointer");

						switch (this.pointerY) {
							case 0: // Buy Now!!
								location.href = URL_STORE;
								break;
							case 1: // Maybe later
								horde.sound.stop("victory");
								this.initGame();
								break;
						}

					}

				}

				if (
					(this.state === "credits")
				) {
					if (this.keyboard.isAnyKeyPressed() || this.mouse.isAnyButtonDown()) {
						kb.clearKeys();
						this.mouse.clearButtons();
						this.state = "title";
					}
				}

				if (this.state === "intro_cinematic") {
					if (this.keyboard.isAnyKeyPressed() || this.mouse.isAnyButtonDown()) {
						kb.clearKeys();
						this.mouse.clearButtons();
						this.state = "running";
						var player = this.getPlayerObject();
						this.woundsTo = player.wounds;
						this.currentMusic = "normal_battle_music";
						horde.sound.play(this.currentMusic);
					}
				}

				if (usingPointerOptions) {

					if (
						this.keyboard.isKeyPressed(keys.W)
						|| this.keyboard.isKeyPressed(keys.UP)
					) {
						this.keyboard.keyStates[keys.W] = false;
						this.keyboard.keyStates[keys.UP] = false;
						this.pointerY--;
						if (this.pointerY < this.pointerOptionsStart) this.pointerY = this.maxPointerY;
						horde.sound.play("move_pointer");
					}
					if (
						this.keyboard.isKeyPressed(keys.S)
						|| this.keyboard.isKeyPressed(keys.DOWN)
					) {
						this.keyboard.keyStates[keys.S] = false;
						this.keyboard.keyStates[keys.DOWN] = false;
						this.pointerY++;
						if (this.pointerY > this.maxPointerY) this.pointerY = this.pointerOptionsStart;
						horde.sound.play("move_pointer");
					}

					this.keyboard.storeKeyStates();

					if (newPointerY !== undefined) {
						horde.sound.play("move_pointer");
						this.pointerY = newPointerY;
					}

				}

				if (this.state === "running") {
					var player = this.getPlayerObject();

					if (this.paused || player.hasState(horde.Object.states.DYING)) {
						this.keyboard.storeKeyStates();
						return;
					}

					if (!this.touchMove) {
						this.updateTargetReticle();
					} else {
						this.targetReticle.angle += (((Math.PI * 2) / 5000) * this.lastElapsed);
						if (this.targetReticle.angle > (Math.PI * 2)) {
							this.targetReticle.angle = 0;
						}
						if (
							this.mouse.wasButtonClicked(buttons.LEFT)
							|| this.mouse.isButtonDown(buttons.LEFT)
						) {
							var mouseBounds = new horde.Rect(
								48, 80, SCREEN_WIDTH - 96, SCREEN_HEIGHT - 192
							);
							var trp = this.targetReticle.position;
							// Adjust the X position
							if (mouseV.x < mouseBounds.left) {
								trp.x = mouseBounds.left;
							} else if (mouseV.x > mouseBounds.left + mouseBounds.width) {
								trp.x = mouseBounds.left + mouseBounds.width;
							} else {
								trp.x = mouseV.x;
							}
							// Adjust the Y position
							if (mouseV.y < mouseBounds.top) {
								trp.y = mouseBounds.top;
							} else if (mouseV.y > mouseBounds.top + mouseBounds.height) {
								trp.y = mouseBounds.top + mouseBounds.height;
							} else {
								trp.y = mouseV.y;
							}
						}
					}

					var move = new horde.Vector2();
					var shoot = new horde.Vector2();

					if (this.touchMove) {

						// Auto Target
						var hostile = this.getNearestHostile(player);
						if (hostile !== null) {
							shoot = hostile.boundingBox().center().subtract(
								player.boundingBox().center()
							).normalize();
						}

						// Move towards reticle
						move = this.targetReticle.position.clone().subtract(
							player.boundingBox().center()
						).normalize();
						var distance = this.targetReticle.position.clone().subtract(
							player.boundingBox().center()
						).magnitude();
						if (distance < 3) {
							move.zero();
						}

					} else {

						if (this.wasdMovesArrowsAttack) {
							var controls = {
								moveUp: keys.W,
								moveLeft: keys.A,
								moveDown: keys.S,
								moveRight: keys.D,
								attackUp: keys.UP,
								attackDown: keys.DOWN,
								attackLeft: keys.LEFT,
								attackRight: keys.RIGHT
							};
						} else {
							var controls = {
								moveUp: keys.UP,
								moveDown: keys.DOWN,
								moveLeft: keys.LEFT,
								moveRight: keys.RIGHT,
								attackUp: keys.W,
								attackLeft: keys.A,
								attackDown: keys.S,
								attackRight: keys.D
							};
						}

						// Moving
						if (kb.isKeyDown(controls.moveUp)) {
							move.y = -1;
							this.nextTutorial(1);
						}
						if (kb.isKeyDown(controls.moveLeft)) {
							move.x = -1;
							this.nextTutorial(1);
						}
						if (kb.isKeyDown(controls.moveDown)) {
							move.y = 1;
							this.nextTutorial(1);
						}
						if (kb.isKeyDown(controls.moveRight)) {
							move.x = 1;
							this.nextTutorial(1);
						}

						// Shooting
						if (kb.isKeyDown(controls.attackUp)) {
							shoot.y = -1;
							this.nextTutorial(2);
						}
						if (kb.isKeyDown(controls.attackDown)) {
							shoot.y = 1;
							this.nextTutorial(2);
						}
						if (kb.isKeyDown(controls.attackLeft)) {
							shoot.x = -1;
							this.nextTutorial(2);
						}
						if (kb.isKeyDown(controls.attackRight)) {
							shoot.x = 1;
							this.nextTutorial(2);
						}

					}

					// Move the player
					player.stopMoving();
					if ((move.x !== 0) || (move.y !== 0)) {
						player.setDirection(move);
					}

					if (this.mouse.wasButtonClicked(buttons.LEFT)) {
						if (
							this.showTutorial
							&& (mouseV.y <= (TUTORIAL_HEIGHT + this.tutorialY))
						) {
							// Dismiss tutorial
							this.tutorialIndex = TUTORIAL_NUM_TIPS;
							this.nextTutorial(TUTORIAL_NUM_TIPS + 1);
							this.mouse.clearButtons();
						} else if (
							mouseV.x >= 604
							&& mouseV.x <= 636
							&& mouseV.y >= 442
							&& mouseV.y <= 475
						) {
							if (this.canFullscreen) {
								this.toggleFullscreen();
								this.mouse.clearButtons();
							} else {
								this.togglePause();
							}
						} else if (
							this.canMute
							&& ((mouseV.x >= 570) && (mouseV.x <= 602))
							&& ((mouseV.y >= 442) && (mouseV.y <= 484))
						) {
							// Toggle mute
							horde.sound.toggleMuted();
							this.mouse.clearButtons();
						}
					}

					if (this.mouse.isButtonDown(buttons.LEFT) && !this.touchMove) {
						var v = this.targetReticle.position.clone().subtract(player.boundingBox().center()).normalize();
						this.objectAttack(player, v);
						this.heroFiring = true;
						this.heroFiringDirection = v;
						this.nextTutorial(4);
						this.showReticle = true;
					} else if (shoot.x !== 0 || shoot.y !== 0) {
						this.objectAttack(player, shoot);
						this.heroFiring = true;
						this.heroFiringDirection = shoot;
					} else {
						this.heroFiring = false;
						this.heroFiringDirection = null;
					}

					this.keyboard.storeKeyStates();
					this.mouse.storeButtonStates();
				}

			};

			proto.getNearestHostile = function (object) {
				var nearest = {
					obj: null,
					distance: Infinity
				};
				for (var id in this.objects) {
					var o = this.objects[id];
					if (
						o.team != object.team
						&& (o.role == "monster" || o.role == "projectile")
						&& o.hitPoints !== Infinity
						&& this.isAlive(o.id)
						&& !(o.hasState(horde.Object.states.INVINCIBLE) || o.hasState(horde.Object.states.INVISIBLE))
					) {
						var distance = object.boundingBox().center().subtract(
							o.boundingBox().center()
						).magnitude();
						if (distance < nearest.distance) {
							nearest.obj = o;
							nearest.distance = distance;
						}
					}
				}
				if (nearest.obj === null) {
					return null;
				} else {
					return nearest.obj;
				}
			};

			proto.objectAttack = function (object, v) {

				if (!v) {
					v = object.facing;
				}

				var weaponType = object.fireWeapon();
				if (weaponType === false) {
					return;
				}

				var weaponDef = horde.objectTypes[weaponType];

				switch (weaponType) {

					case "e_minotaur_trident":
						var h = v.heading();
						for (var x = -0.5; x <= 0.5; x += 0.5) {
							this.spawnObject(
								object,
								weaponType,
								horde.Vector2.fromHeading(h + x)
							);
						}
						object.shotsFired += 3;
						break;

					// Shoot 2 knives in a spread pattern
					case "h_knife":
					case "h_fire_knife":
						var h = v.heading();
						this.spawnObject(object, weaponType, horde.Vector2.fromHeading(
							h - 0.1
						));
						this.spawnObject(object, weaponType, horde.Vector2.fromHeading(
							h + 0.1
						));
						object.shotsFired += 2;
						break;

					// Spread fire shotgun style
					case "e_fireball_green":
						for (var x = -0.25; x <= 0.25; x += 0.25) {
							var h = v.heading();
							h += (x + (horde.randomRange(-1, 1) / 10));
							this.spawnObject(
								object,
								weaponType,
								horde.Vector2.fromHeading(h)
							);
						}
						object.shotsFired += 3;
						break;

					case "h_fireball":
						var h = v.heading();
						var vh = horde.Vector2.fromHeading(h);

						var id = this.spawnObject(object, weaponType, vh.clone());
						var o = this.objects[id];
						o.position.add(horde.Vector2.fromHeading(h - (Math.PI / 2)).scale(16));
						o.position.add(vh.clone().scale(16));

						var id = this.spawnObject(object, weaponType, vh.clone());
						var o = this.objects[id];
						o.position.add(vh.clone().scale(32));

						var id = this.spawnObject(object, weaponType, vh.clone());
						var o = this.objects[id];
						o.position.add(horde.Vector2.fromHeading(h + (Math.PI / 2)).scale(16));
						o.position.add(vh.clone().scale(16));
						object.shotsFired += 3;
						break;

					case "h_firebomb":
						var rv = this.targetReticle.position.clone();
						var len = (Math.PI * 2);
						var step = (len / 20);

						for (var h = 0; h < len; h += step) {
							var o = horde.makeObject("h_fireball");
							o.position.x = rv.x - 16;
							o.position.y = rv.y - 16;
							o.setDirection(horde.Vector2.fromHeading(h));
							o.ownerId = object.id;
							o.team = object.team;
							this.addObject(o);
							object.shotsFired += 1;
						}
						break;

					// Shoot 5 firebursts out in a spread pattern
					/*
					case "h_fireburst":
						var h = v.heading();
						this.spawnObject(object, weaponType, horde.Vector2.fromHeading(
							h - 0.4
						));
						this.spawnObject(object, weaponType, horde.Vector2.fromHeading(
							h - 0.2
						));
						this.spawnObject(object, weaponType, horde.Vector2.fromHeading(
							h
						));
						this.spawnObject(object, weaponType, horde.Vector2.fromHeading(
							h + 0.2
						));
						this.spawnObject(object, weaponType, horde.Vector2.fromHeading(
							h + 0.4
						));
						object.shotsFired += 5;
						break;
						*/

					case "e_ring_fire":
						var len = (Math.PI * 2);
						var step = (len / 10);
						var seed = (step / 2);
						for (var h = seed; h < len + seed; h += step) {
							this.spawnObject(
								object,
								weaponType,
								horde.Vector2.fromHeading(h)
							);
						}
						break;

						case "e_ring_fire_dopp":
							var len = (Math.PI * 2);
							var step = (len / 10);
							for (var h = 0; h < len; h += step) {
								this.spawnObject(
									object,
									weaponType,
									horde.Vector2.fromHeading(h)
								);
							}
							break;

					// Spawn in a circle around the object
					case "e_bouncing_boulder":
						var len = (Math.PI * 2);
						var step = (len / 8);
						for (var h = 0; h < len; h += step) {
							this.spawnObject(
								object,
								weaponType,
								horde.Vector2.fromHeading(h)
							);
						}
						break;

					// Shoot one instance of the weapon
					default:
						this.spawnObject(object, weaponType, v);
						object.shotsFired++;
						break;

				}

				// Increment shots per weapon counter
				if (!object.shotsPerWeapon[weaponType]) {
					object.shotsPerWeapon[weaponType] = 0;
				}
				object.shotsPerWeapon[weaponType]++;

				// Determine what sound (if any) to play
				// Attacking sound on weapon type > attacking sound on object performing attack
				var sound = null;
				if (weaponDef.soundAttacks) {
					sound = weaponDef.soundAttacks;
				} else if (object.soundAttacks) {
					sound = object.soundAttacks;
				}
				if (sound !== null) {
					horde.sound.play(sound);
				}

			};

			proto.render = function horde_Engine_proto_render () {

				var ctx = this.canvases["display"].getContext("2d");

				switch (this.state) {

					// Company Logo
					case "intro":
						this.drawLogo(ctx);
						break;

					// Title Screen
					case "title":
						this.drawTitle(ctx);
						this.drawPointer(ctx);
						this.drawTitlePointerOptions(ctx);
						break;

					// Credits
					case "credits":
						this.drawTitle(ctx);
						this.drawCredits(ctx);
						break;

					case "intro_cinematic":
						this.drawIntroCinematic(ctx);
						break;

					// The game!
					case "running":
						this.drawFloor(ctx);
						if (!this.wonGame) {
							this.drawTargetReticle(ctx);
						}
						this.drawObjects(ctx);
						this.drawFauxGates(ctx);
						this.drawWalls(ctx);
						this.drawWeaponPickup(ctx);
						this.drawCoinPickup(ctx);
						this.drawWaveText(ctx);
						this.drawUI(ctx);
						if (this.paused) {
							this.drawPaused(ctx);
							this.drawPointer(ctx);
							this.drawPausedPointerOptions(ctx);
						}
						if (this.showTutorial) {
							this.drawTutorial(ctx);
						}
						break;

					case "game_over":
						this.drawGameOver(ctx);
						break;

					case "buy_now":
						this.drawBuyNow(ctx);
						this.drawPointer(ctx);
						break;

				}

				if (this.debug === true) {
					this.drawDebugInfo(ctx);
				}

			};

			proto.drawWeaponPickup = function horde_Engine_proto_drawWeaponPickup (ctx) {
				var w = this.weaponPickup;
				if (w.state === "on") {
					var type = horde.makeObject(w.type);
					ctx.save();
					ctx.translate(
						w.position.x + (type.size.width / 2),
						w.position.y + (type.size.height / 2)
					);
					ctx.globalAlpha = w.alpha;
					// Draw scroll
					ctx.drawImage(
						this.images.getImage("objects"),
						128, 192, 48, 48,
						-22 * w.scale, -20 * w.scale, 48 * w.scale, 48 * w.scale
					);
					// Draw weapon
					ctx.drawImage(
						this.images.getImage(type.spriteSheet),
						type.spriteX, type.spriteY + 1, type.size.width - 1, type.size.height - 1,
						-((type.size.width / 2) * w.scale), -((type.size.height / 2) * w.scale),
						type.size.width * w.scale, type.size.height * w.scale
					);
					ctx.restore();
				}
			};

			proto.drawCoinPickup = function horde_Engine_proto_drawCoinPickup (ctx) {
				var w = this.coinPickup;
				if (w.state === "on") {
					var meta = this.getCoinFontData(w.amount);
					var text = ("+" + w.amount);

					ctx.save();
					ctx.fillStyle = meta.fillStyle;
					ctx.font = ("Bold " + meta.size + "px MedievalSharp");
					ctx.lineWidth = 2;
					ctx.strokeStyle = COLOR_BLACK;
					ctx.textAlign = "center";
					ctx.textBaseline = "top";
					ctx.translate(
						w.position.x,
						w.position.y
					);
					ctx.globalAlpha = w.alpha;
					ctx.strokeText(text, 0, 0);
					ctx.fillText(text, 0, 0);
					ctx.restore();
				}
			};

			proto.getCoinFontData = function horde_Engine_proto_getCoinFontData (amount) {
				if (amount == 100) {
					return {
						fillStyle: "rgb(255, 203, 5)",
						size: 24
					};
				} else if (amount == 500) {
					return {
						fillStyle: "rgb(255, 244, 96)",
						size: 36
					};
				} else {
					return {
						fillStyle: "rgb(255, 248, 160)",
						size: 50
					};
				}
			};

			proto.drawWaveText = function horde_Engine_proto_drawWaveText (ctx) {
				// Back out immediately if we shoudn't draw
				if (this.waveText.state == "off") {
					return;
				}

				var size = parseInt(this.waveText.size);
				var width = (this.waveText.width * size);
				var height = WAVE_TEXT_HEIGHT * size;
				var x = (SCREEN_WIDTH/2) - (width/2);
				var y = (SCREEN_HEIGHT/2) - (height/2);

				ctx.save();
				ctx.globalAlpha = this.waveText.alpha;
				ctx.drawImage(
					this.canvases.waveText,
					0, 0, this.waveText.width, WAVE_TEXT_HEIGHT,
					x, y, width, height
				);
				ctx.restore();
			};

			/**
			* Draws the game over screen.
			* @param {object} Canvas 2d context to draw on.
			*/
			proto.drawGameOver = function horde_Engine_proto_drawGameOver (ctx) {

				if (this.goAlphaStep) {
					this.goAlpha += this.goAlphaStep;
					if (this.goAlpha <= 0) {
						this.goAlpha = 0;
						this.goAlphaStep = 0.025;
					}
					if (this.goAlpha >= 1) {
						this.goAlpha = 1;
						this.goAlphaStep = -0.025;
					}
				} else {
					this.goAlphaStep = -0.025;
					this.goAlpha = 1;
				}

				if (!this.gameOverBg) {
					this.drawUI(ctx);
					this.gameOverBg = ctx.getImageData(0, 0, this.view.width, this.view.height);
				}

				ctx.putImageData(this.gameOverBg, 0, 0);

				ctx.save();
				ctx.globalAlpha = this.gameOverAlpha;
				if (this.wonGame) {
					ctx.fillStyle = COLOR_BLACK;
				} else {
					ctx.fillStyle = "rgb(215, 25, 32)"; // red
				}
				ctx.fillRect(0, 0, this.view.width, this.view.height);
				ctx.restore();

				if (this.gameOverReady === true) {

					if (this.keyboard.isAnyKeyPressed() || this.mouse.isAnyButtonDown()) {
						this.keyboard.clearKeys();
						this.mouse.clearButtons();
						this.statsIndex += 1;
						if (this.statsIndex >= 5) {
							if (horde.isDemo()) {
								this.state = "buy_now";
								this.initOptions();
							} else {
								horde.sound.stop("victory");
								this.initGame();
							}
							return;
						}
					}

					var headerY = 70;

					// Modal
					ctx.drawImage(
						this.preloader.getImage("ui"),
						0, 2322, 564, 404,
						38, 38, 564, 404
					);

					// Game Over
					if (this.wonGame) {
						ctx.drawImage(
							this.preloader.getImage("ui"),
							564, 2444, 256, 50,
							192, headerY, 256, 50
						);
					} else if (this.gotNewHighScore) {
						ctx.drawImage(
							this.preloader.getImage("ui"),
							564, 2374, 404, 50,
							119, headerY, 404, 50
						);
					} else {
						ctx.drawImage(
							this.preloader.getImage("ui"),
							564, 2324, 218, 50,
							211, headerY, 218, 50
						);
					}

					this.drawObjectStats(this.getPlayerObject(), ctx);

					// Press anything to continue ...
					if (this.statsIndex >= 4) {
						ctx.drawImage(
							this.preloader.getImage("ui"),
							564, 2424, 334, 20,
							153, 404, 334, 20
						);
					}

				}

			};

			proto.drawBuyNow = function horde_Engine_proto_drawBuyNow (ctx) {

				ctx.save();

				ctx.globalAlpha = OVERLAY_ALPHA;
				ctx.fillRect(0, 0, this.view.width, this.view.height);

				ctx.globalAlpha = 1;
				ctx.drawImage(
					this.preloader.getImage("ui"),
					370, 0, 564, 404,
					38, 38, 564, 404
				);
				ctx.restore();

				var startY = (this.pointerYStart - 22);
				var spriteX;

				// Buy Now!!
				spriteX = ((this.pointerY == 0) ? 260 : 0);
				ctx.drawImage(
					this.preloader.getImage("ui"),
					spriteX, 2122, 200, 40,
					POINTER_X, startY, 200, 40
				);

				// Maybe later
				spriteX = ((this.pointerY == 1) ? 260 : 0);
				startY += POINTER_HEIGHT;
				ctx.drawImage(
					this.preloader.getImage("ui"),
					spriteX, 2182, 200, 40,
					POINTER_X, startY, 200, 40
				);

			};

			proto.drawObjectStats = function horde_Engine_proto_drawObjectStats (object, ctx) {

				var textX = 350;
				var textHeight = 55;

				ctx.save();
				ctx.font = "Bold 40px MedievalSharp";

				var increment;
				var max = 0;
				var nextTimer = 0;

				var wavesComplete = this.currentWaveId;

				if (this.wonGame) {
					wavesComplete += 1;
				}

				// Waves
				var displayWave = 0;
				if (this.statsIndex === 0) {
					displayWave = this.statsCount;
					max = wavesComplete;
					// Settings for Gold earned:
					increment = 199;
					nextTimer = 10;
				} else {
					displayWave = wavesComplete;
				}
				ctx.fillStyle = "rgb(199, 234, 251)";
				ctx.fillText(displayWave + " x 1000", textX, 182);

				// Gold earned
				var displayGold = 0;
				if (this.statsIndex === 1) {
					displayGold = this.statsCount;
					max = object.gold;
					// Settings for Damage taken:
					increment = 10;
					nextTimer = 10;
				} else if (this.statsIndex > 1) {
					displayGold = object.gold;
				}
				ctx.fillStyle = "rgb(255, 245, 121)";
				ctx.fillText(displayGold, textX, (180 + textHeight));

				// Damage taken
				var displayDamage = 0;
				if (this.statsIndex === 2) {
					displayDamage = this.statsCount;
					max = object.totalDamageTaken;
					// Settings for Total score:
					increment = 299;
					nextTimer = 5;
				} else if (this.statsIndex > 2) {
					displayDamage = object.totalDamageTaken;
				}
				ctx.fillStyle = "rgb(237, 28, 36)";
				ctx.fillText("-" + displayDamage + " x 10", textX, 180 + (textHeight * 2));

				// Total score
				var displayScore = "";
				var totalScore = this.getTotalScore();
				if (this.statsIndex === 3) {
					displayScore = this.statsCount;
					max = totalScore;
				} else if (this.statsIndex > 3) {
					displayScore = totalScore;
				}
				ctx.fillStyle = "rgb(250, 166, 26)";
				ctx.fillText(displayScore, textX, (184 + (textHeight * 3)));

				if (this.statsCount >= max) {
					this.statsCount = 0;
					this.statsIncrement = increment;
					this.statsIndex += 1;
					this.statsTimer.start(nextTimer);
				}

				ctx.restore();

			};

			/**
			* Calculates the player's total score
			*/
			proto.getTotalScore = function () {

				var player = this.getPlayerObject();
				var wavesComplete = this.currentWaveId;

				if (this.wonGame) {
					wavesComplete += 1;
				}

				var score = (wavesComplete * 1000);
				score += player.gold;
				score -= (player.totalDamageTaken * 10);

				if (player.cheater === true) {
					score /= 2;
				}

				if (score < 0) {
					score = 0;
				}

				return score;
			};

			proto.drawLogo = function horde_Engine_proto_drawLogo (ctx) {

				// Clear the screen
				ctx.save();
				ctx.fillStyle = COLOR_BLACK;
				ctx.fillRect(0, 0, this.view.width, this.view.height);
				ctx.restore();

				// Draw the logo
				if (this.logoAlpha > 0) {
					ctx.save();
					ctx.globalAlpha = this.logoAlpha;
					ctx.drawImage(
						this.preloader.getImage("ui"),
						0, 0, 370, 430,
						160, 0, 370, 430
					);
					ctx.restore();
				}

			};

			proto.drawFloor = function horde_Engine_proto_drawFloor (ctx) {
				var offset = this.getArenaOffset();
				ctx.drawImage(
					this.images.getImage("arena"),
					(offset + 32), 480, 576, 386,
					32, 0, 576, 386
				);
			};

			proto.drawWalls = function horde_Engine_proto_drawWalls (ctx) {
				var offset = this.getArenaOffset();
				ctx.drawImage(
					this.images.getImage("arena"),
					offset, 0, SCREEN_WIDTH, SCREEN_HEIGHT,
					0, 0, this.view.width, this.view.height
				);
			};

			proto.getArenaOffset = function horde_Engine_proto_getArenaOffset () {
			var waveId = ((this.currentWaveId >= 0) ? this.currentWaveId : 0);
				return (SCREEN_WIDTH * Math.floor(waveId / 10));
			};

			proto.drawPaused = function horde_Engine_proto_drawPaused (ctx) {

				ctx.save();

				ctx.globalAlpha = OVERLAY_ALPHA;
				ctx.fillRect(0, 0, this.view.width, this.view.height);

				ctx.globalAlpha = 1;
				ctx.drawImage(
					this.preloader.getImage("ui"),
					0, 1718, 564, 404,
					38, 38, 564, 404
				);

				var player = this.getPlayerObject();

				ctx.font = "Bold 36px MedievalSharp";
				ctx.textAlign = "left";

				ctx.fillStyle = "rgb(237, 28, 36)";
				ctx.fillText(player.kills, 390, 164);

				ctx.fillStyle = "rgb(145, 102, 0)";
				ctx.fillText(player.meatEaten, 390, 216);

				ctx.fillStyle = "rgb(199, 234, 251)";
				ctx.fillText(player.shotsFired, 390, 270);

				ctx.fillStyle = "rgb(250, 166, 26)";
				ctx.fillText(this.getAccuracy(player) + "%", 390, 324);

				ctx.restore();

			};

			proto.getAccuracy = function horde_Engine_proto_getAccuracy (player) {
				if (player.shotsFired === 0) return 0;

				return Math.round((player.shotsLanded / player.shotsFired) * 100);
			};

			proto.drawTutorial = function horde_Engine_proto_drawTutorial (ctx) {

				if (this.paused) return;

				ctx.save();
				ctx.globalAlpha = OVERLAY_ALPHA;
				ctx.fillRect(0, this.tutorialY, this.view.width, TUTORIAL_HEIGHT);

				ctx.globalAlpha = 1;
				ctx.font = "Bold 22px MedievalSharp";
				ctx.textAlign = "center";

				var tips = [
					"MOVE with the WASD keys.",
					"ATTACK with the ARROW keys.",
					"Or use the MOUSE to AIM with the target reticle.",
					"ATTACK by HOLDING DOWN the LEFT MOUSE BUTTON.",
					"KILL MONSTERS and COLLECT GOLD to raise your score!"
				];

				ctx.fillStyle = COLOR_BLACK;
				ctx.fillText(tips[this.tutorialIndex], 322, (this.tutorialY + 36));

				ctx.fillStyle = "rgb(230, 230, 230)";
				ctx.fillText(tips[this.tutorialIndex], 320, (this.tutorialY + 34));

				ctx.font = "20px MedievalSharp";

				var pressHere = "Press here or ESC to skip";
				ctx.fillStyle = COLOR_BLACK;
				ctx.fillText(pressHere, 322, (this.tutorialY + 62));

				ctx.fillStyle = "rgb(118, 151, 183)";
				ctx.fillText(pressHere, 320, (this.tutorialY + 60));
				ctx.restore();

			};

			/**
			* Returns the draw order of objects based on their Y position + height
			* @return {array} Array of object IDs in the order that they should be drawn
			*/
			proto.getObjectDrawOrder = function horde_Engine_proto_getObjectDrawOrder () {
				var drawOrder = [];
				for (var id in this.objects) {
					var obj = this.objects[id];
					drawOrder.push({
						id: obj.id,
						drawIndex: obj.drawIndex,
						y: obj.position.y + obj.size.height
					});
				}
				drawOrder.sort(function (a, b) {
					if (a.drawIndex === b.drawIndex) {
						return (a.y - b.y);
					} else {
						return (a.drawIndex - b.drawIndex);
					}
				});
				return drawOrder;
			};

			proto.drawObject = function horde_Engine_proto_drawObject (ctx, o) {

				if (o.role === "hero" && this.heroFiring) {
					var s = o.getSpriteXY(this.heroFiringDirection);
				} else {
					var s = o.getSpriteXY();
				}

				/*
				// Invisible testing hack
				if (o.hasState(horde.Object.states.INVISIBLE)) {
					ctx.save();
					ctx.fillStyle = "rgb(0, 0, 255)";
					ctx.fillRect(
						o.position.x,
						o.position.y,
						o.size.width,
						o.size.height
					);
					ctx.restore();
					return;
				}
				*/

				if (o.alpha <= 0 || o.hasState(horde.Object.states.INVISIBLE)) {
					return;
				}

				ctx.save();

				ctx.translate(
					o.position.x + o.size.width / 2,
					o.position.y + o.size.height / 2
				);

				if (o.angle !== 0) {
					ctx.rotate(o.angle * Math.PI / 180);
				}

				if (o.alpha !== 1) {
					ctx.globalAlpha = o.alpha;
				}

				if (o.role === "powerup_weapon") {
					// Draw a scroll behind the weapon
					ctx.drawImage(
						this.images.getImage("objects"),
						128, 192, 48, 48, -22, -20, 48, 48
					);
				}

				ctx.drawImage(
					this.images.getImage(o.spriteSheet),
					s.x, s.y + 1, o.size.width - 1, o.size.height - 1,
					-(o.size.width / 2), -(o.size.height / 2), o.size.width, o.size.height
				);

				if (o.spriteYOverlay) {
					ctx.save();
					var alpha = (1 - (o.wounds / o.hitPoints)) + 0.3;
					ctx.globalAlpha = alpha;
					ctx.drawImage(
						this.images.getImage(o.spriteSheet),
						s.x, o.spriteYOverlay + 1, o.size.width - 1, o.size.height - 1,
						-(o.size.width / 2), -(o.size.height / 2), o.size.width, o.size.height
					);
					ctx.restore();
				}

				// Boss pain!
				if (
					(o.role === "monster")
					&& o.badass
					&& o.hasState(horde.Object.states.HURTING)
				) {
					this.drawImageOverlay(
						ctx, this.images.getImage(o.spriteSheet),
						s.x, s.y + 1, o.size.width - 1, o.size.height - 1,
						-(o.size.width / 2), -(o.size.height / 2), o.size.width, o.size.height,
						"rgba(186, 51, 35, 0.6)"
					);
				}

				// Message indestructible enemy projectiles
				if (this.isBadassWeapon(o) && o.glow) {
					this.drawImageOverlay(
						ctx, this.images.getImage(o.spriteSheet),
						s.x, s.y + 1, o.size.width - 1, o.size.height - 1,
						-(o.size.width / 2), -(o.size.height / 2), o.size.width, o.size.height,
						"rgba(255, 247, 143, " + o.glow.alpha + ")"
					);
				}

				// HP bar
				if (
					(this.debug && (o.role === "monster"))
					|| (o.badass && !o.hasState(horde.Object.states.DYING))
				) {
					var hpWidth = (o.size.width - 2);
					var hpHeight = 8;
					var width = (hpWidth - Math.round((hpWidth * o.wounds) / o.hitPoints));

					ctx.fillStyle = COLOR_WHITE;
					ctx.fillRect(-(o.size.width / 2), (o.size.height / 2), o.size.width, hpHeight);
					ctx.fillStyle = COLOR_BLACK;
					ctx.fillRect(-(o.size.width / 2) + 1, ((o.size.height / 2) + 1), (o.size.width - 2), (hpHeight - 2));
					ctx.fillStyle = this.getBarColor(o.hitPoints, (o.hitPoints - o.wounds));
					ctx.fillRect(-(o.size.width / 2) + 1, ((o.size.height / 2) + 1), width, (hpHeight - 2));
				}

				ctx.restore();

			};

			proto.isBadassWeapon = function horde_Engine_proto_isBadassWeapon (o) {
				return (
					(o.role === "projectile")
					&& (o.hitPoints === Infinity)
					&& (o.team === 1)
					&& (o.type != "e_fireball")
					&& (o.type != "e_static_blue_fire")
					&& (o.type != "e_static_green_fire")
				);
			}

			proto.drawObjects = function (ctx) {
				var drawOrder = this.getObjectDrawOrder();
				for (var x in drawOrder) {
					var o = this.objects[drawOrder[x].id];
					this.drawObject(ctx, o);
				}
			};

			/**
			* Draws the targeting reticle to the screen
			* @param {object} Canvas 2d context to draw on
			* @return {void}
			*/
			proto.drawTargetReticle = function horde_Engine_proto_drawTargetReticle (ctx) {

				if (!this.showReticle) return;

				ctx.save();
				ctx.globalAlpha = 0.75;
				ctx.translate(this.targetReticle.position.x, this.targetReticle.position.y);
				ctx.rotate(this.targetReticle.angle);
				ctx.drawImage(
					this.images.getImage("objects"),
					256, 192, 64, 64,
					-32, -32, 64, 64
				);
				ctx.restore();
			};

			/**
			* Draws an overlay over an image in its exact shape (exact pixels)
			* @param too many, shut up :(
			* @return {void}
			*/
			proto.drawImageOverlay = function horde_Engine_proto_drawImageOverlay (
				ctx, image,
				spriteX, spriteY,
				spriteWidth, spriteHeight,
				destX, destY,
				destWidth, destHeight,
				fillStyle
			) {

				var buffer = this.canvases.buffer.getContext("2d");
				buffer.save();
				buffer.clearRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

				buffer.drawImage(
					image,
					spriteX, spriteY, spriteWidth, spriteHeight,
					0, 0,
					destWidth, destHeight
				);
				buffer.globalCompositeOperation = "source-in";
				buffer.fillStyle = fillStyle;
				buffer.fillRect(0, 0, destWidth, destHeight);
				buffer.restore();

				ctx.drawImage(
					this.canvases.buffer,
					0, 0,
					destWidth, destHeight,
					destX, destY,
					destWidth, destHeight
				);

			};

			/**
			* Draws the game UI
			* @param {object} Canvas 2d context to draw on
			* @return {void}
			*/
			proto.drawUI = function horde_Engine_proto_drawUI (ctx) {

				var o = this.getPlayerObject();
				var weaponInfo = o.getWeaponInfo();
				var w = horde.objectTypes[weaponInfo.type];
				var wCount = (weaponInfo.count ? weaponInfo.count : "");

				// Weapon Icon
				ctx.drawImage(
					this.images.getImage("objects"),
					w.spriteX, w.spriteY, 32, 32,
					4, 412, 32, 32
				);

				// Score icon
				ctx.drawImage(
					this.images.getImage("objects"),
					32, 32, 32, 32,
					4, 442, 32, 32
				);

				// Draw gold amount and weapon count
				ctx.save();
				ctx.textAlign = "left";
				ctx.font = "Bold 32px MedievalSharp";

				ctx.globalAlpha = 0.75;
				ctx.fillStyle = COLOR_BLACK;
				ctx.fillText(wCount, 48, 444);
				ctx.fillText(this.scoreCount, 48, 474);

				ctx.globalAlpha = 1;
				ctx.fillStyle = COLOR_WHITE;
				ctx.fillText(wCount, 46, 440);
				ctx.fillText(this.scoreCount, 46, 472);
				ctx.restore();

				if (o.hitPoints > 1) {

					// Health bar
					var bar = {
						width: 280,
						height: 24,
						x: 212,
						y: 432
					};

					var width1 = (bar.width - Math.round((bar.width * o.wounds) / o.hitPoints));
					var width2 = (bar.width - Math.round((bar.width * this.woundsTo) / o.hitPoints));

					if (this.woundsTo < o.wounds) {
						var width = width1;
						var toWidth = width2;
					} else {
						var width = width2;
						var toWidth = width1;
					}

					// Outside border
					ctx.save();
					ctx.fillStyle = COLOR_WHITE;
					ctx.fillRect(bar.x - 2, bar.y - 2, bar.width + 2, bar.height + 4);
					ctx.fillRect(bar.x + bar.width, bar.y, 2, bar.height);
					ctx.fillStyle = COLOR_BLACK;
					ctx.fillRect(bar.x, bar.y, bar.width, bar.height);

					// The bar itself
					ctx.fillStyle = this.getBarColor(o.hitPoints, (o.hitPoints - o.wounds));
					ctx.globalAlpha = 0.4;

					ctx.fillRect(bar.x, bar.y, toWidth, bar.height);

					ctx.fillRect(bar.x, bar.y, width, bar.height);
					ctx.fillRect(bar.x, bar.y + 5, width, bar.height - 10);
					ctx.fillRect(bar.x, bar.y + 10, width, bar.height - 20);
					ctx.restore();

					// Heart icon
					var percentage = (((o.hitPoints - o.wounds) / o.hitPoints) * 100);
					var spriteX = 352;
					if (percentage > 50) {
						spriteX = 224;
					} else if (percentage > 25) {
						spriteX = 288;
					}
					ctx.drawImage(
						this.images.getImage("objects"),
						spriteX, 64, 42, 42,
						(bar.x - 32), 424, 42, 42
					);

				}

				// Mute button
				if (this.canMute) {
					ctx.drawImage(
						this.preloader.getImage("ui"),
						(horde.sound.isMuted() ? 692 : 660), 910, 32, 32,
						570, 442, 32, 32
					);
				}

				// Fullscreen toggle icon
				if (this.canFullscreen) {
					var spriteX = (this.enableFullscreen ? 596 : 564);
					ctx.drawImage(
						this.preloader.getImage("ui"),
						spriteX, 910, 32, 32,
						604, 442, 32, 32
					);
				} else {
					ctx.drawImage(
						this.preloader.getImage("ui"),
						596+32, 910, 32, 32,
						604, 442, 32, 32
					);
				}

			};

			/**
			* Draws the title screen.
			* @param {object} Canvas 2d context to draw on.
			* @return {void}
			*/
			proto.drawTitle = function horde_Engine_proto_drawTitle (ctx) {

				var grey = "rgb(230, 230, 230)";

				ctx.drawImage(
					this.preloader.getImage("ui"),
					0, 430, 640, 480,
					0, 0, 640, 480
				);

				var highScore = ("High Score: " + this.getData(HIGH_SCORE_KEY));

				ctx.save();
				ctx.font = "Bold 24px MedievalSharp";
				ctx.textAlign = "center";

				ctx.fillStyle = COLOR_BLACK;
				ctx.fillText(highScore, 322, 444);

				ctx.fillStyle = grey;
				ctx.fillText(highScore, 320, 442);
				ctx.restore();



				// Version
				var version = ("v" + VERSION);
				if (horde.isDemo()) version += " demo";
				ctx.save();
				ctx.font = "Bold 14px Monospace";
				ctx.textAlign = "right";

				ctx.fillStyle = COLOR_BLACK;
				ctx.fillText(version, 638, 480);

				ctx.fillStyle = grey;
				ctx.fillText(version, 636, 478);
				ctx.restore();

				// Copyright text
				var copyright = "Lost Decade Games";
				ctx.save();
				ctx.font = "Bold 14px Monospace";

				ctx.fillStyle = COLOR_BLACK;
				ctx.fillText(copyright, 6, 462);

				ctx.fillStyle = grey;
				ctx.fillText(copyright, 4, 460);
				ctx.restore();

				var copyrightDate = "\u00A9 2010";
				ctx.save();
				ctx.font = "Bold 14px Monospace";

				ctx.fillStyle = COLOR_BLACK;
				ctx.fillText(copyrightDate, 6, 478);

				ctx.fillStyle = grey;
				ctx.fillText(copyrightDate, 4, 476);
				ctx.restore();

			};

			proto.drawPointer = function horde_Engine_proto_drawPointer (ctx) {

				var textY = (this.pointerYStart - 18);
				var x = (POINTER_X - 42);
				var y = (this.pointerYStart + (this.pointerY * POINTER_HEIGHT) - POINTER_HEIGHT);

				ctx.save();
				ctx.drawImage(
					this.images.getImage("objects"),
					320, 192, 36, 26,
					x, y,
					36, 26
				);
				ctx.restore();

			};

			/**
			* @param {Boolean} checkAgain If true, will grab info from Clay again (set when logging in)
			* @return {Boolean} true if the checkpoint is stored
			*/
			proto.canContinue = function (checkAgain) {

				if( this.canContinueVar ) { // already grabbed from Clay.io
					var checkpointWave = this.canContinueVar;
					return checkpointWave;
				}

				if(!this.grabbingContinueVar) {
					this.grabbingContinueVar = true;
					var _this = this;
					Clay.ready(function() {
						var checkpointWave = _this.getData("checkpoint_wave", function(response) {
							_this.canContinueVar = Boolean(response.data);
						});
						Clay.Player.onUserReady( function() {
							_this.canContinue(true); // refresh w/ new data
						} );
					});
				}
				var checkpointWave = this.getData("checkpoint_wave"); // fallback to local data (while the clay data loads);
				return Boolean(checkpointWave);
			};

			proto.drawTitlePointerOptions = function horde_Engine_proto_drawTitlePointerOptions (ctx) {

				var startY = (this.pointerYStart - 22);
				var spriteY;

				if (horde.isDemo()) {
					// Buy now!!
					spriteY = ((this.pointerY == 0) ? 638 : 430);
					ctx.drawImage(
						this.preloader.getImage("ui"),
						800, spriteY, 128, 26,
						POINTER_X, startY, 128, 26
					);
				} else {
					// Continue
					if (this.canContinue()) {
						spriteY = ((this.pointerY == 0) ? 638 : 430);
					} else {
						spriteY = 534;
					}
					ctx.drawImage(
						this.preloader.getImage("ui"),
						640, spriteY, 116, 20,
						POINTER_X, startY, 116, 20
					);
				}

				// New game
				spriteY = ((this.pointerY == 1) ? 664 : 456);
				ctx.drawImage(
					this.preloader.getImage("ui"),
					640, spriteY, 132, 26,
					POINTER_X, (startY + POINTER_HEIGHT), 132, 26
				);

				// Credits
				spriteY = ((this.pointerY == 2) ? 690 : 482);
				ctx.drawImage(
					this.preloader.getImage("ui"),
					640, spriteY, 90, 22,
					POINTER_X, (startY + (POINTER_HEIGHT * 2)), 90, 22
				);

			};

			proto.drawPausedPointerOptions = function horde_Engine_proto_drawPausedPointerOptions (ctx) {

				var startY = (this.pointerYStart - 22);
				var spriteY;

				if (this.verifyQuit) {
					// Nevermind
					spriteY = ((this.pointerY == 0) ? 1932 : 1860);
					ctx.drawImage(
						this.preloader.getImage("ui"),
						564, spriteY, 158, 26,
						POINTER_X, startY, 158, 26
					);
				} else {
					// Resume
					spriteY = ((this.pointerY == 0) ? 1788 : 1718);
					ctx.drawImage(
						this.preloader.getImage("ui"),
						564, spriteY, 106, 26,
						POINTER_X, startY, 106, 26
					);
				}

				if (this.verifyQuit) {
					// Quit, seriously
					spriteY = ((this.pointerY == 1) ? 1966 : 1894);
					ctx.drawImage(
						this.preloader.getImage("ui"),
						564, spriteY, 192, 32,
						POINTER_X, (startY + POINTER_HEIGHT), 196, 32
					);
				} else {
					// Quit
					spriteY = ((this.pointerY == 1) ? 1822 : 1752);
					ctx.drawImage(
						this.preloader.getImage("ui"),
						564, spriteY, 70, 36,
						POINTER_X, (startY + POINTER_HEIGHT), 70, 36
					);
				}

			};

			proto.initOptions = function () {

				switch (this.state) {
					case "title":
						this.pointerYStart = 314;

						if (horde.isDemo() || this.canContinue()) {
							this.pointerY = 0;
							this.pointerOptionsStart = 0;
						} else {
							this.pointerY = 1;
							this.pointerOptionsStart = 1;
						}
						this.maxPointerY = 2;
						break;
					case "running":
						this.pointerYStart = 378;
						this.pointerY = 0;
						this.maxPointerY = 1;
						this.pointerOptionsStart = 0;
						this.verifyQuit = false;
						break;
					case "buy_now":
						this.pointerYStart = 378;
						this.pointerY = 0;
						this.maxPointerY = 1;
						this.pointerOptionsStart = 0;
						break;
				}

			};

			proto.drawCredits = function horde_Engine_proto_drawCredits (ctx) {
				ctx.save();
				ctx.globalAlpha = OVERLAY_ALPHA;
				ctx.fillRect(0, 0, this.view.width, this.view.height);
				ctx.globalAlpha = 1;
				ctx.drawImage(
					this.preloader.getImage("ui"),
					0, 1314, 564, 404,
					38, 38, 564, 404
				);
				ctx.restore();
			};

			proto.drawIntroCinematic = function horde_Engine_proto_drawIntroCinematic (ctx) {

				switch (this.introPhase) {

					case 0:
						if (!this.introFadeOutBg) {
							this.introFadeOutBg = ctx.getImageData(0, 0, this.view.width, this.view.height);
							this.introFadeAlpha = 0;
						}
						ctx.fillStyle = COLOR_BLACK;
						ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
						ctx.save();
						ctx.putImageData(this.introFadeOutBg, 0, 0);
						ctx.restore();
						if (this.introFadeAlpha > 0) {
							ctx.save();
							ctx.globalAlpha = this.introFadeAlpha;
							ctx.fillStyle = COLOR_BLACK;
							ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
							ctx.restore();
						}
						break;

					case 1:
						this.drawFloor(ctx);
						this.drawFauxGates(ctx);
						this.drawWalls(ctx);
						if (this.introFadeAlpha > 0) {
							ctx.save();
							ctx.globalAlpha = this.introFadeAlpha;
							ctx.fillStyle = COLOR_BLACK;
							ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
							ctx.restore();
						}
						break;

					case 2:
					case 3:
						this.drawFloor(ctx);
						this.drawFauxGates(ctx);
						this.drawWalls(ctx);
						break;

					case 4:
					case 5:
					case 9:
						this.drawFloor(ctx);
						if (this.introHero) {
							this.drawObject(ctx, this.introHero);
						}
						this.drawFauxGates(ctx);
						this.drawWalls(ctx);
						break;

					case 6:
					case 7:
					case 8:
						this.drawFloor(ctx);
						ctx.drawImage(this.images.getImage("characters"),
							20 * 32, 0, 32, 32,
							304, 224, 32, 32
						);
						this.drawFauxGates(ctx);
						this.drawWalls(ctx);
						break;
				}


			};

			/**
			* Draws fake gates for the title screen
			* @param {object} Canvas 2d context
			* @return {void}
			*/
			proto.drawFauxGates = function horde_Engine_proto_drawFauxGates (ctx) {
				for (var g = 0; g < NUM_GATES; g++) {
					var spriteX = 0;
					var spriteY = 192;

					if (g > 0) {
						spriteX = 320;
						spriteY = ((g == 1) ? 288 : 352);
					}

					ctx.drawImage(
						this.images.getImage("objects"),
						spriteX, spriteY, 64, 64,
						(this.gatesX + 96 + (g * 192)), this.gatesY, 64, 64
					);
				}
			};

			/**
			* Draws debugging information to the screen
			* @param {object} Canvas 2d context
			* @return {void}
			*/
			proto.drawDebugInfo = function horde_Engine_proto_drawDebugInfo (ctx) {

				// Semi-transparent bar so we can see the text
				ctx.save();
				ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
				ctx.fillRect(0, 0, this.view.width, 30);
				ctx.restore();

				// Debugging info
				ctx.save();
				ctx.fillStyle = COLOR_WHITE;
				ctx.font = "Bold 20px Monospace";
				ctx.fillText("Elapsed: " + this.lastElapsed, 10, 20);
				ctx.textAlign = "right";
				ctx.fillText(Math.round(1000 / this.lastElapsed) + " FPS", 630, 20);
				ctx.restore();

			};

			/**
			* Fetches some persistent data. Grabs first from Clay.io, falls back to localStorage, and local variable
			* @param {String} key The key of the data to fetch
			* @param {Function} callback Callback function if useClay is set to true (since data isn't immeditely available).
			* 							  The first parameter of this function is an object { success: boolean, data: String }
			* @param {Boolean} forceClay Forces fetch from Clay.io (instead of using local)
			* @return {String} The data (or undefined on failure)
			*/
			proto.getData = function horde_Engine_proto_getData (key, callback, forceClay) {
				// Load in the Clay data if it exists, otherwise fallback to localStorage
				if(callback) {
					if(Clay.isReady && Clay.Player.loggedIn && (forceClay || !horde.localData[key])) {
						var handler = function(response) {
							horde.localData[key] = { value: response.data, times: 0, timeout: null }; // save locally for future reference
							callback(response);
						}
						Clay.Player.fetchUserData(key, handler);
					}
					else if(horde.localData[key]) { // we're already storing the data locally, no need to fetch from Clay
						callback({ data: horde.localData[key].value, usingVar: true });
					}
					else { // Data not stored locally, and can't fetch from Clay
						callback({ data: window.localStorage.getItem(key), usingLocalStorage: true });
						horde.localData[key] = window.localStorage.getItem(key); // save locally for future reference
					}
					return undefined;
				}
				if (window.localStorage && window.localStorage.getItem) {
					return window.localStorage.getItem(key);
				}
				return undefined;
			};

			/**
			* Saves some data persistently. Saves to localStorage, a variable, and Clay.io (after 3 seconds)
			* @param {String} key The key of the data to store
			* @param {String} value The data to store
			*/
			proto.putData = function horde_Engine_proto_putData (key, value) {
				if (window.localStorage && window.localStorage.setItem) {
					window.localStorage.setItem(key, value);
				}
				// Clay.io: Store to Clay.io as well (as primary source of storage, localStorage as backup)
				// We store to Clay.io if new data isn't passed in 3s
				// This is in place so we're not flooding Clay.io with data stores (there is a limit...)
				if(!Clay.isReady)
					return false;

				if(horde.localData[key] && horde.localData[key].timeout) {
					clearTimeout(horde.localData[key].timeout);
					var times = horde.localData[times] + 1; // log how many times the timeout is set, so every 10th, we'll store anyways
				}
				else {
					var times = 0; // first time setting the timeout
				}

				// Store the data locally, and store to Clay after 3 seconds on non-changing data
				( function() {
					var localKey = key;
					var localValue = value;
					var localTimes = times;
					horde.localData[key] = { value: localValue, times: localTimes, timeout: setTimeout(function() {
						Clay.Player.saveUserData(localKey, localValue);
						horde.localData[localKey].timeout = null;
					}, 3000) };
				} )();
			};

			/**
			* Clears some persistent data by key
			* @param {String} key The key of the data to clear
			*/
			proto.clearData = function horde_Engine_proto_clearData (key) {
				if (window.localStorage && window.localStorage.removeItem) {
					window.localStorage.removeItem(key);
				}
			};

			proto.endGame = function () {
				this.gameOverReady = false;
				this.gameOverAlpha = 0;
				this.updateGameOver();
				this.state = "game_over";
				this.timePlayed = (horde.now() - this.gameStartTime);
			};

			proto.toggleFullscreen = function () {
				horde.sound.play("select_pointer");
				this.enableFullscreen = !this.enableFullscreen;
				var fullscreenPref = (this.enableFullscreen ? 1 : 0);
				this.putData("fullscreen", fullscreenPref);
				this.resize();
			};

			}());


		(function define_horde_Object () {

			/**
			 * Horde Game Object
			 * @constructor
			 */
			horde.Object = function () {
				this.id = ""; // Object ID
				this.ownerId = null; // Owner object ID
				this.position = new horde.Vector2(); // Object's position on the map
				this.size = new horde.Size(32, 32); // Size of the object
				this.direction = new horde.Vector2(); // Direction the object is moving
				this.facing = new horde.Vector2(0, 1); // Direction the object is facing
				this.speed = 100; // The speed at which the object moves
				this.team = null; // Which "team" the object is on (null = neutral)
				this.hitPoints = 1; // Hit points
				this.damage = 1; // Amount of damage object deals when colliding with enemies
				this.spriteSheet = ""; // Sprite sheet where this object's graphics are found
				this.spriteX = 0; // X location of spirte
				this.spriteY = 0; // Y location of sprite
				this.spriteAlign = false; // Align sprite with facing
				this.animated = false; // Animated or not
				this.animFrameIndex = 0; // Current animation frame to display
				this.animNumFrames = 2;
				this.animDelay = 200; // Delay (in milliseconds) between animation frames
				this.animElapsed = 0; // Elapsed time (in milliseconds) since last animation frame increment
				this.spawnFrameIndex = 0;
				this.spawnFrameCount = 2;
				this.spawnFramesX = 0;
				this.spawnFramesY = 0;
				this.angle = 0; // Angle to draw this object
				this.rotateSpeed = 400; // Speed at which to rotate the object
				this.rotate = false; // Enable/disable rotation of object
				this.worth = 0; // Amount of gold this object is worth when killed
				this.ttl = 0; // How long (in milliseconds) this object *should* exist (0 = no TTL)
				this.ttlElapsed = 0; // How long (in milliseconds) this object *has* existed
				this.alpha = 1; // Alpha value for drawing this object
				this.alphaMod = 1; // Alpha modifier (fadin [1] vs fadeout [-1])
				this.gibletSize = "small"; // Size of giblets to spawn when this objects "dies"
				this.cooldown = false; // Whether or not the object's attack is on cooldown
				this.cooldownElapsed = 0; // How long the object's attack has been on cooldown
				this.autoFire = false; // Enable/disable auto fire
				this.soundAttacks = null; // Sound to play when object attacks
				this.soundDamage = null; // Sound to play when object takes damage
				this.soundDies = null; // Sound to play when object dies
				this.alive = true;
				this.states = [];
				this.addState(horde.Object.states.IDLE);
				this.currentWeaponIndex = 0;
				this.collidable = true;
				this.bounce = true;
				this.piercing = false;

				// Clay.io
				this.achievementId = null; // Related Clay.io Achievement ID
				this.deathsForAchievement = Infinity; // # of kills necessary necessary to earn achievement
				this.ignoreLogDeath = false; // If set to true, the # of deaths isn't logged (in Clay.io data-storage)

				// Default sounds
				this.soundDamage = null;
				this.soundDies = null;

				this.damageType = "physical";

				this.drawIndex = 1; // Controls what order objects are drawn, lower is first

				// AI stuff
				this.moveChangeElapsed = 0;
				this.moveChangeDelay = 500;

				this.wounds = 0; // Amount of damage object has sustained
				this.weapons = [];
				this.gold = 0; // Amount of gold this object has earned

				// Stats!
				this.kills = 0;
				this.timesWounded = 0;
				this.totalDamageTaken = 0;
				this.shotsFired = 0;
				this.shotsLanded = 0;
				this.shotsPerWeapon = {};
				this.meatEaten = 0;
				this.cheater = false;

				// Behavior phase stuff
				this.phase = 0;
				this.phaseInit = false;

				// Loot tables for enemies
				this.lootTable = [];

				this.killSwitch = false;
			};

			horde.Object.states = {
				IDLE: 0,
				MOVING: 1,
				ATTACKING: 2,
				HURTING: 3,
				DYING: 4,
				INVINCIBLE: 5,
				INVISIBLE: 6,
				SPAWNING: 7,
				DESPAWNING: 8,
				STUNNED: 9,
				VICTORIOUS: 10
			};

			var proto = horde.Object.prototype;

			/**
			 * Populates this object's key stats from a JSON dump
			 * @param {string} json JSON dump of an object
			 * @return {void}
			 */
			proto.load = function horde_Object_load (json) {
				var data = JSON.parse(json);
				this.wounds = data.wounds;
				this.weapons = data.weapons;
				this.currentWeaponIndex = data.currentWeaponIndex;
				this.gold = data.gold;
				this.kills = data.kills;
				this.timesWounded = data.timesWounded;
				this.totalDamageTaken = data.totalDamageTaken;
				this.shotsFired = data.shotsFired;
				this.shotsLanded = data.shotsLanded;
				this.shotsPerWeapon = data.shotsPerWeapon;
				this.meatEaten = data.meatEaten;
				this.cheater = data.cheater;
			};

			proto.setPhase = function (phase) {
				this.phase = phase;
				this.phaseInit = false;
			}

			proto.nextPhase = function () {
				this.setPhase(this.phase + 1);
			};

			proto.updateStates = function (elapsed) {
				for (var x in this.states) {
					var s = this.states[x];
					s.timer.update(elapsed);
					if (s.timer.expired()) {
						this.removeStateById(x);
						continue;
					}
				}
			};

			proto.hasState = function (state) {
				for (var x in this.states) {
					if (this.states[x].type === state) {
						return true;
					}
				}
				return false;
			};

			proto.addState = function (state, ttl) {
				if (this.hasState(state)) {
					return false;
				}
				var t = new horde.Timer();
				t.start(ttl);
				this.states.push({
					type: state,
					timer: t
				});
				switch (state) {
					case horde.Object.states.SLOWED:
						this.oldAnimDelay = this.animDelay;
						this.animDelay *= 2;
						break;
				}
			};

			proto.removeStateById = function (id) {
				var s = this.states[id];
				switch (s.type) {
					case horde.Object.states.INVINCIBLE:
						this.alpha = 1;
						this.alphaMod = -1;
						break;
					case horde.Object.states.SLOWED:
						this.animDelay = this.oldAnimDelay;
						break;
				}
				delete(this.states[id]);
			};

			proto.removeState = function (state) {
				for (var x in this.states) {
					if (this.states[x].type === state) {
						this.removeStateById(x);
					}
				}
			};

			/**
			 * Runs any initialization
			 * @return {void}
			 */
			proto.init = function horde_Object_proto_init () {
				this.execute("onInit");
				if (this.rotate) {
					this.angle = horde.randomRange(0, 359);
				}
				if (this.animated) {
					this.animElapsed = horde.randomRange(0, this.animDelay);
				}
			};

			/**
			 * Causes this object to die. Do not pass go, do not collect $200.
			 * @return {void}
			 */
			proto.die = function horde_Object_proto_die () {
				this.alive = false;

				// Clay.io: Log the death for things like achievements
				if((this.role == "monster" || this.role == "projectile") && !this.ignoreLogDeath) // Certain projectiles are ignored (ex. fire_sword_trail)
					this.logDeath();
			};

			/**
			 * Logs when a monster or projectile "dies". This is later used for Clay.io achievements (ex. kill 1000 bats)
			 * @return {void}
			 */
			proto.logDeath = function horde_Object_proto_logDeath () {
				// Clay.io: Update number of enemies killed
				var deaths = 0;
				var key = this.type + "_killed";
				var _this = this;

				if (this.achievementId !== null) {
					horde.Engine.prototype.getData(key, function(response) {
						deaths = (response.data ? response.data : 0) + 1;
						horde.Engine.prototype.putData(key, deaths);

			/* 			// Clay.io: check if there's an achievement for killing this specific thing x times
						if(_this.achievementId && deaths >= _this.deathsForAchievement && !horde.achievementsGranted[_this.achievementId])
						{
							horde.achievementsGranted[_this.achievementId] = true; // so we don't keep sending to Clay.io
							(new Clay.Achievement({ id: _this.achievementId })).award();
						} */
					});
				}

				if(this.role == "monster") {
					// Update overall kills
					var key = "overall_killed";
					horde.Engine.prototype.getData(key, function(response) {
						deaths = (response.data ? response.data : 0) + 1;
						horde.Engine.prototype.putData(key, deaths);

						// See if they're at achievement for overall kills
						achievementId = "killenemies";
						// 10,000 kills for the achievement
			/* 			if(deaths >= 10000 && !horde.achievementsGranted[achievementId]) {
							horde.achievementsGranted[achievementId] = true; // so we don't keep sending to Clay.io
							(new Clay.Achievement({ id: achievementId })).award();
						} */
					});
				}
			}

			/**
			 * Returns whether or not this object is "dead" (this.alive === false)
			 * @return {boolean} True if the object is dead; otherwise false
			 */
			proto.isDead = function horde_Object_proto_isDead () {
				return !this.alive;
			}

			/**
			 * Update this object
			 * @param {number} elapsed Elapsed time in milliseconds since last update
			 * @return {void}
			 */
			proto.update = function horde_Object_proto_update (elapsed, engine) {

				// If the owner has died, kill off this object
				if (
					this.killSwitch === false
					&& this.ownerId !== null
					&& !engine.isAlive(this.ownerId)
				) {
					switch (this.role) {
						case "projectile":
						case "trap":
							this.ttl = 1000;
							this.ttlElapsed = 0;
							break;
						case "monster":
							this.wound(this.hitPoints);
							break;
					}
					this.killSwitch = true;
				}

				this.updateStates(elapsed);

				if (this.deathTimer) {
					this.deathTimer.update(elapsed);
				}

				if (this.hasState(horde.Object.states.DYING)) {
					if (this.deathTimer.expired()) {
						this.deathFrameIndex++;
						this.deathTimer.reset();
						if (this.deathFrameIndex > 2) {
							this.deathFrameIndex = 2;
							this.ttl = 750;
						}
					}
				}

				if (this.hasState(horde.Object.states.INVINCIBLE)) {
					this.alpha += ((10 / 1000) * elapsed) * this.alphaMod;
					if (this.alpha >= 1) {
						this.alpha = 1;
						this.alphaMod = -1;
					}
					if (this.alpha <= 0) {
						this.alpha = 0;
						this.alphaMod = 1;
					}
				}

				if (this.hasState(horde.Object.states.STUNNED)) {
					return;
				}

				if (this.animated) {
					this.animElapsed += elapsed;
					if (this.animElapsed >= this.animDelay) {
						this.animElapsed = 0;
						this.animFrameIndex++;
						if (this.animFrameIndex > (this.animNumFrames - 1)) {
							this.animFrameIndex = 0;
						}
						if (this.hasState(horde.Object.states.SPAWNING)) {
							this.spawnFrameIndex++;
							if (this.spawnFrameIndex > this.spawnFrameCount) {
								this.removeState(horde.Object.states.SPAWNING);
							}
						}
						if (this.hasState(horde.Object.states.DESPAWNING)) {
							this.spawnFrameIndex--;
							if (this.spawnFrameIndex < 0) {
								this.removeState(horde.Object.states.DESPAWNING);
							}
						}
					}
				}

				if (this.spriteAlign) {
					this.angle = this.facing.angle();
				}

				if (this.rotate) {
					this.angle += ((this.rotateSpeed / 1000) * elapsed);
				}
				if (this.ttl > 0) {
					this.ttlElapsed += elapsed;
					if (this.ttl - this.ttlElapsed <= 1000) {
						this.alpha -= ((1 / 1000) * elapsed);
					}
					if (this.ttlElapsed >= this.ttl) {
						this.die();
					}
				}
				if (this.cooldown === true) {
					this.cooldownElapsed += elapsed;
					var wepInfo = this.getWeaponInfo();
					var wep = horde.objectTypes[wepInfo.type];
					if (this.cooldownElapsed >= wep.cooldown) {
						this.cooldown = false;
						this.cooldownElapsed = 0;
					}
				}

				if (this.phaseTimer) {
					this.phaseTimer.update(elapsed);
				}

				if (this.hasState(horde.Object.states.DYING)) {
					// Don't proceed with calling any AI behavior if this thing is dying...
					return;
				}

				return this.execute("onUpdate", arguments);
			};

			/**
			 * Returns the XY coordinates of this objects sprite
			 * @return {horde.Vector2} XY coordinates of sprite to draw
			 */
			proto.getSpriteXY = function horde_Object_proto_getSpriteXY (facingOverride) {
				if (this.animated) {
					switch (this.role) {

						case "hero":
						case "monster":
							if (this.hasState(horde.Object.states.DYING)) {
								return new horde.Vector2(
									(17 + this.deathFrameIndex) * this.size.width, this.spriteY
								);
							}
							if (
								this.hasState(horde.Object.states.SPAWNING)
								|| this.hasState(horde.Object.states.DESPAWNING)
							) {
								return new horde.Vector2(
									this.spawnFramesX + (this.spawnFrameIndex * this.size.width),
									this.spawnFramesY
								);
							}
							if (this.hasState(horde.Object.states.HURTING) && this.size.width <= 32) {
								return new horde.Vector2(
									16 * this.size.width, this.spriteY
								);
							}
							if (this.hasState(horde.Object.states.VICTORIOUS)) {
								return new horde.Vector2(
									20 * this.size.width, this.spriteY
								);
							}
							if (facingOverride) {
								var f = facingOverride;
							} else {
								var f = this.facing.clone();
							}
							var offset = horde.directions.fromVector(f);
							return new horde.Vector2(
								((offset * 2) + this.animFrameIndex) * this.size.width,
								this.spriteY
							);
							break;

						default:
							if (
								this.hasState(horde.Object.states.SPAWNING)
								|| this.hasState(horde.Object.states.DESPAWNING)
							) {
								return new horde.Vector2(
									this.spawnFramesX + (this.spawnFrameIndex * this.size.width),
									this.spawnFramesY
								);
							}
							return new horde.Vector2(
								this.spriteX + (this.animFrameIndex * this.size.width),
								this.spriteY
							);
							break;

					}

				} else {
					return new horde.Vector2(this.spriteX, this.spriteY);
				}
			};

			/**
			 * Returns the bounding box for this object
			 * @return {horde.Rect} Rectangle representing the bounding box
			 */
			proto.boundingBox = function horde_Object_proto_boundingBox () {
				var rect = new horde.Rect(
					this.position.x, this.position.y,
					this.size.width - 1, this.size.height - 1
				);
				if (this.role === "projectile") {
					rect.reduce(1);
				}
				if (this.type === "e_spit_pool") {
					// Kind of a hack...
					rect.y += (this.size.height / 4);
					rect.x += 5;
					rect.height -= (this.size.height / 2);
					rect.width -= 10;
				}
				if (this.type === "gas_cloud") {
					rect.y += 32;
					rect.x += 32;
					rect.height -= 32;
					rect.width -= 32;
				}
				return rect;
			};

			/**
			 * Centers this object on a point
			 * @param {horde.Vector2} v Vector to center on
			 * @return {void}
			 */
			proto.centerOn = function horde_Object_proto_centerOn (v) {
				this.position = v.subtract(horde.Vector2.fromSize(this.size).scale(0.5));
			};

			/**
			 * Deal some damage (or wound) this object
			 * @param {number} damage The amount of damage to deal
			 * @return {boolean} True if the object has died; otherwise false
			 */
			proto.wound = function horde_Object_proto_wound (damage) {
				if (
					(damage < 1)
					|| this.hasState(horde.Object.states.DYING)
					|| this.isDead()
				) {
					return false;
				}
				this.removeState(horde.Object.states.STUNNED);
				this.wounds += damage;
				this.totalDamageTaken += damage;
				this.timesWounded++;
				if (this.role === "monster" || this.role === "hero") {
					this.addState(horde.Object.states.HURTING, 300);
				}
				if (this.wounds >= this.hitPoints) {
					this.wounds = this.hitPoints;
					if (this.role === "monster" || this.role === "hero") {
						this.addState(horde.Object.states.DYING);
						this.deathFrameIndex = 0;
						this.deathTimer = new horde.Timer();
						this.deathTimer.start(200);
					} else {
						this.die();
					}
					if (this.role === "hero") {
						horde.sound.stopAll();
					}
					if (this.soundDies) {
						horde.sound.play(this.soundDies);
					}
					return true;
				}
				if (this.soundDamage) {
					horde.sound.play(this.soundDamage);
				}
				return false;
			};

			/**
			 * Handles when this object collides with a wall
			 * @param {array} axis Array of axes where collision occurred (x, y)
			 * @return {void}
			 */
			proto.wallCollide = function horde_Object_proto_wallCollide (axis) {
				if (this.role === "hero") {
					return;
				}
				if (this.bounce) {
					// reverse direction(s)
					var d = this.direction.clone();
					for (var i in axis) {
						d[axis[i]] *= -1;
					}
					this.setDirection(d);
					if (this.role === "projectile") {
						horde.sound.play("weapon_wall");
					}
				} else {
					if (this.damageType === "physical") {
						this.deflect();
					} else {
						this.die();
					}
				}
				this.execute("onWallCollide", [axis]);
			};

			proto.deflect = function horde_Object_proto_deflect () {
				this.role = "fluff";
				this.rotateSpeed = this.speed * 5;
				this.speed *= 0.50;
				this.spriteAlign = false;
				this.rotate = true;
				this.ttl = 100;
				this.alpha = 0.5;
				this.bounce = true;
			};

			/**
			 * Sets the direction (and facing) for this object
			 * @param {horde.Vector2} v Vector representing the direction
			 * @return {void}
			 */
			proto.setDirection = function horde_Object_proto_setDirection (v) {
				if (v.x === 0 && v.y === 0) {
					this.stopMoving();
				} else {
					this.direction = v;
					this.facing = this.direction.clone();
				}
			};

			proto.reverseDirection = function () {
				var d = this.direction.clone();
				d.scale(-1);
				this.setDirection(d);
			};

			/**
			 * "Chases" another object by setting this objects direction toward another
			 * @return {void}
			 */
			proto.chase = function horde_Object_proto_chase (object) {
				this.moveToward(object.position.clone());
			};

			proto.moveToward = function horde_Object_proto_moveToward (vector) {
				var direction = vector.clone().subtract(this.position).normalize();
				this.setDirection(direction);
			};

			/**
			 * Returns if this object is moving or not
			 * @return {boolean} True if the object is moving, otherwise false
			 */
			proto.isMoving = function horde_Object_proto_isMoving () {
				if (this.hasState(horde.Object.states.DYING)) {
					return false;
				}
				return (this.direction.x !== 0 || this.direction.y !== 0);
			};

			/**
			 * Stops this object from moving (resets direction vector to zero)
			 * @return {void}
			 */
			proto.stopMoving = function horde_Object_proto_stopMoving () {
				this.direction.zero();
			};

			/**
			 * Executes a method that may or may not exist
			 * @param {string} method Method to call
			 * @param {array} args Array of arguments
			 * @return {void}
			 */
			proto.execute = function horde_Object_proto_execute (method, args) {
				if (this[method]) {
					return this[method].apply(this, args);
				}
			};

			/**
			 * Returns the weapon info for this object's current weapon
			 * @return {object} Weapon info (type & count)
			 */
			proto.getWeaponInfo = function horde_Object_proto_getWeaponInfo () {
				var len = this.weapons.length;
				if (len >= 1) {
					// Object has at least one weapon
					if (this.currentWeaponIndex < 0) {
						this.currentWeaponIndex = 0;
					}
					if (this.currentWeaponIndex > len - 1) {
						this.currentWeaponIndex = len - 1;
					}
					return this.weapons[this.currentWeaponIndex];
				}
				return false;
			};

			proto.addWeapon = function horde_Object_proto_addWeapon (type, count) {

				var remIndices = [];

				// Adjust count if player already has some of this weapon type
				// Also, store non-infite weapons for later removal
				for (var x in this.weapons) {
					var w = this.weapons[x]; // Haha, Weapon X
					if (typeof(w) !== "undefined" && w.type === type) {
						if (w.count !== null) {
							count += w.count;
						} else {
							count = null;
						}
					}
					if (w.count !== null) {
						remIndices.push(x);
					}
				}

				// Remove specified weapons
				for (var index in remIndices) {
					this.weapons = this.weapons.splice(index, 1);
				}

				var len = this.weapons.push({
					type: type,
					count: count
				});

				this.currentWeaponIndex = (len - 1);

			};

			proto.cycleWeapon = function horde_Object_proto_cycleWeapon (reverse) {
				var len = this.weapons.length;
				if (reverse === true) {
					this.currentWeaponIndex--;
					if (this.currentWeaponIndex < 0) {
						this.currentWeaponIndex = len - 1;
					}
				} else {
					this.currentWeaponIndex++;
					if (this.currentWeaponIndex > len - 1) {
						this.currentWeaponIndex = 0;
					}
				}
			};

			/**
			 * "Fires" the current weapon by reducing the weapon count and returning the type
			 * @return {string} Weapon type to spawn
			 */
			proto.fireWeapon = function horde_Object_proto_fireWeapon () {
				var len = this.weapons.length;
				if (this.cooldown === true || len < 1) {
					return false;
				}
				var currentWeapon = this.getWeaponInfo();
				if (currentWeapon.count !== null) {
					currentWeapon.count -= 1;
					if (currentWeapon.count < 1) {
						this.weapons.splice(this.currentWeaponIndex, 1);
					}
				}
				this.cooldown = true;
				return currentWeapon.type;
			};

			/**
			 * Returns whether or not this object has a given weapon type
			 * @param {string} type Weapon type
			 * @return {boolean}
			 */
			proto.hasWeapon = function horde_Object_proto_hasWeapon (type) {
				var len = this.weapons.length;
				for (var x = 0; x < len; ++x) {
					var weapon = this.weapons[x];
					if (weapon.type === type) {
						return true;
					}
				}
				return false;
			};

			}());

		(function defne_horde_objectTypes () {

		horde.objectTypes = {};

		var o = horde.objectTypes;

		o.hero = {
			role: "hero",
			team: 0,
			speed: 150,
			hitPoints: 100,
			damage: 0,
			damageType: null,
			spriteSheet: "characters",
			spriteY: 992,
			animated: true,
			soundAttacks: "hero_attacks",
			soundDamage: "hero_damage",
			soundDies: "hero_dies",
			weapons: [
				{type: "h_sword", count: null}
			],
			isMeatboy: false,
			bloodTimer: null,

			onInit: function () {
				if (this.isMeatboy) {
					this.initMeatBoy();
				}
			},

			initMeatBoy: function () {
				this.hitPoints = 1;
				this.spriteY = 1024;
				this.bloodTimer = new horde.Timer();
				this.bloodTimer.start(100);
			},

			onUpdate: function (elapsed, engine) {
				if (this.isMeatboy) {
					this.bloodTimer.update(elapsed);
					if (this.bloodTimer.expired() && this.isMoving()) {
						var id = engine.spawnObject(this, "blood_pool");
						var o = engine.objects[id];
						o.position.x += horde.randomRange(-8, 8);
						o.position.y += horde.randomRange(-8, 8);
						o.angle = horde.randomRange(0, Math.PI * 1.5);
						this.bloodTimer.start(horde.randomRange(75, 150));
					}
				}
			},

			onKilled: function (attacker, engine) {
				var num = 10;
				for (var i = 0; i < num; ++i) {
					var skull = horde.makeObject("mini_skull");
					skull.position.x = (this.position.x + (i * (this.size.width / num)));
					skull.position.y = (this.position.y + this.size.height - horde.randomRange(0, this.size.height));
					engine.addObject(skull);
				}
			}

		};

		o.blood_pool = {
			role: "fluff",
			size: new horde.Size(32, 32),
			speed: 0,
			ttl: 1250,
			collidable: false,
			spriteSheet: "objects",
			spriteX: 128,
			spriteY: 32,
			drawIndex: 0
		};

		// HERO WEAPONS

		o.h_sword = {
			role: "projectile",
			cooldown: 300,
			speed: 250,
			hitPoints: 1,
			damage: 10,
			spriteSheet: "objects",
			spriteX: 64,
			spriteY: 0,
			spriteAlign: true,
			priority: 0,
			bounce: false,
			
			// Clay.io
			achievementId: "masterswords",
			deathsForAchievement: 1000
		};

		o.h_knife = {
			role: "projectile",
			size: new horde.Size(32, 30),
			cooldown: 200,
			speed: 350,
			hitPoints: 1,
			damage: 5,
			spriteSheet: "objects",
			spriteX: 32,
			spriteY: 0,
			spriteAlign: true,
			priority: 1,
			bounce: false
		};

		o.h_spear = {
			role: "projectile",
			cooldown: 350,
			speed: 500,
			hitPoints: 1,
			damage: 15,
			spriteSheet: "objects",
			spriteX: 96,
			spriteY: 0,
			spriteAlign: true,
			priority: 2,
			bounce: false,
			piercing: true
		};

		o.h_fireball = {
			role: "projectile",
			cooldown: 300,
			speed: 400,
			rotateSpeed: 500,
			hitPoints: 1,
			damage: 3,
			spriteSheet: "objects",
			spriteX: 192,
			spriteY: 0,
			rotate: true,
			ttl: 450,
			soundAttacks: "fire_attack",
			priority: 3,
			bounce: false,
			damageType: "magic",

			onInit: function () {
				this.trailTimer = new horde.Timer();
				this.trailTimer.start(75);
			},

			onUpdate: function (elapsed, engine) {
				this.trailTimer.update(elapsed);
				if (this.trailTimer.expired()) {
					engine.spawnObject(this, "h_fireball_trail");
					this.trailTimer.reset();
				}
			},
			
			// Clay.io
			achievementId: "masterfire",
			deathsForAchievement: 1000

		};

		o.h_fireball_trail = {
			role: "projectile",
			speed: 0,
			rotateSpeed: 150,
			hitPoints: 1,
			damage: 5,
			spriteSheet: "objects",
			spriteX: 192,
			spriteY: 0,
			rotate: true,
			ttl: 500,
			alpha: 0.5,
			priority: 3,
			bounce: false,
			damageType: "magic",
			drawIndex: 0,
			// Clay.io
			ignoreLogDeath: true
		};

		/*
		o.h_bomb = {
			role: "projectile",
			cooldown: 750,
			speed: 200,
			hitPoints: 1,
			damage: 0,
			spriteSheet: "objects",
			spriteX: 128,
			spriteY: 0,
			rotate: true,
			rotateSpeed: 150,
			priority: 4,
			bounce: true,
			
			onDelete: function (engine) {
				engine.spawnObject(this, "bomb_smoke");
			}
			
		};

		o.bomb_smoke = {
			role: "trap",
			size: new horde.Size(64, 64),
			cooldown: 0,
			speed: 0,
			hitPoints: 9999,
			damage: 0,
			spriteSheet: "objects",
			spriteX: 0,
			spriteY: 544,
			bounce: false,
			ttl: 3000,
			
			onDamage: function (defender, engine) {
				if (defender.team !== this.team && defender.role === "monster") {
					defender.addState(horde.Object.states.STUNNED, 5000);
				}
			}
			
		};
		*/

		o.h_axe = {
			role: "projectile",
			cooldown: 500,
			speed: 225,
			hitPoints: 1,
			damage: 20,
			spriteSheet: "objects",
			spriteX: 192,
			spriteY: 32,
			rotate: true,
			rotateSpeed: 700,
			priority: 5,
			ttl: 4000,
			piercing: true,
			
			// Clay.io
			achievementId: "masteraxes",
			deathsForAchievement: 1000
		};

		o.h_fire_sword = {
			role: "projectile",
			cooldown: 450,
			speed: 350,
			hitPoints: 1,
			damage: 25,
			spriteSheet: "objects",
			spriteX: 384,
			spriteY: 0,
			priority: 6,
			bounce: false,
			spriteAlign: true,
			piercing: true,
			soundAttacks: "fire_attack",
			damageType: "magic",
			
			onInit: function () {
				this.spawnTimer = new horde.Timer();
				this.spawnTimer.start(50);
			},
			
			onUpdate: function (elapsed, engine) {
				this.spawnTimer.update(elapsed);
				if (this.spawnTimer.expired()) {
					engine.spawnObject(this, "fire_sword_trail");
					this.spawnTimer.reset();
				}
			},
			
			// Clay.io
			achievementId: "masterfireswords",
			deathsForAchievement: 1000
			
		};

		o.fire_sword_trail = {
			role: "projectile",
			speed: 0,
			hitPoints: 1,
			damage: 10,
			spriteSheet: "objects",
			spriteX: 192,
			spriteY: 0,
			rotate: true,
			soundAttacks: "fire_attack",
			ttl: 500,
			bounce: false,
			drawIndex: 0,
			damageType: "magic",
			// Clay.io
			ignoreLogDeath: true
		};

		o.h_fire_knife = {
			role: "projectile",
			size: new horde.Size(32, 30),
			cooldown: 200,
			speed: 350,
			hitPoints: 1,
			damage: 10,
			spriteSheet: "objects",
			spriteX: 128,
			spriteY: 0,
			priority: 6,
			bounce: false,
			spriteAlign: true,
			piercing: true,
			soundAttacks: "fire_attack",
			damageType: "magic",
			
			onInit: function () {
				this.spawnTimer = new horde.Timer();
				this.spawnTimer.start(50);
			},
			
			onUpdate: function (elapsed, engine) {
				this.spawnTimer.update(elapsed);
				if (this.spawnTimer.expired()) {
					engine.spawnObject(this, "fire_sword_trail");
					this.spawnTimer.reset();
				}
			}
			
		};

		o.h_firebomb = {
			role: "projectile",
			cooldown: 500,
			speed: 150,
			rotateSpeed: 300,
			hitPoints: 1,
			damage: 2,
			spriteSheet: "objects",
			spriteX: 192,
			spriteY: 0,
			rotate: true,
			ttl: 550,
			soundAttacks: "fire_attack",
			priority: 3,
			bounce: false,
			damageType: "magic"
		};

		/*
		o.h_fireburst = {
			role: "projectile",
			size: new horde.Size(32, 32),
			cooldown: 350,
			speed: 250,
			hitPoints: 1,
			damage: 3,
			spriteSheet: "objects",
			spriteX: 96,
			spriteY: 64,
			ttl: 350,
			soundAttacks: "fire_attack",
			spriteAlign: true,
			damageType: "magic",
			priority: 1,
			bounce: false
		};
		*/

		// ENEMIES

		var movementTypes = {
			chase: function (elapsed, engine) {

				if (this.moveChangeDelay > 0) {
					this.moveChangeElapsed += elapsed;
					if (this.moveChangeElapsed < this.moveChangeDelay) {
						return;
					}
					this.moveChangeElapsed = 0;
				}

				var p = engine.getPlayerObject();
				this.chase(p);
				
				return "shoot";

			},
			getNear: function (elapsed, engine) {

				this.speed = this.defaultSpeed;

				var p = engine.getPlayerObject();

				// Get the distance from the player
				var distance = p.position.clone().subtract(this.position).magnitude();
				
				if (distance < 100) {
					// too close! run away
					this.chase(p);
					this.setDirection(this.direction.invert());
				} else if (distance > 150) {
					// too far, chase him down!
					this.chase(p);
				} else if (!this.cooldown) {
					// shoot the fucker in the FACE
					this.chase(p);
					this.speed = 0;
					return "shoot";
				} else {
					movementTypes.wander.apply(this, arguments);
				}

			},
			wander: function (elapsed, engine) {
				this.moveChangeElapsed += elapsed;
				if (this.moveChangeElapsed >= this.moveChangeDelay) {
					this.moveChangeElapsed = 0;
					var d = horde.randomDirection();
					if (d.x === 0 && d.y === 0) { return; }
					this.setDirection(d);
				}
			},
			wanderShoot: function (elapsed, engine) {
				
				var p = engine.getPlayerObject();
				
				var diff = p.position.clone().subtract(this.position).abs();
				
				if (!this.cooldown && (diff.x < (p.size.width / 2) || diff.y < (p.size.height / 2))) {
					this.chase(p);
					return "shoot";
				} else {
					movementTypes.wander.apply(this, arguments);
				}
				
			},
			wanderThenChase: function (elapsed, engine) {

				var p = engine.getPlayerObject();
				var hero = {
					x : p.position.x,
					y : p.position.y
				};
				var x = this.position.x;
				var y = this.position.y;

				if (this.seenHero) {
					movementTypes.chase.apply(this, arguments);
				} else {

					movementTypes.wander.apply(this, arguments);

					var nearX = Math.abs(x - hero.x);
					var nearY = Math.abs(y - hero.y);

					if ((nearX < 64) && (nearY < 64)) {
						horde.sound.play(this.soundAttacks);
						this.seenHero = true;
						return "shoot";
					}

				}

			}
		};

		o.bat = {
			role: "monster",
			team: 1,
			speed: 100,
			hitPoints: 5,
			damage: 2,
			worth: 0,
			spriteSheet: "characters",
			spriteY: 96,
			animated: true,
			animDelay: 150,
			moveChangeElapsed: 0,
			moveChangeDelay: 500,
			soundDamage: "bat_damage",
			soundDies: "bat_dies",
			
			// Clay.io
			achievementId: "killbats",
			deathsForAchievement: 1000,
			
			lootTable: [
				{type: null, weight: 9},
				{type: "item_coin", weight: 1}
			],
			
			onInit: function () {
				this.moveChangeDelay = horde.randomRange(500, 1000);
			},
			onUpdate: function () {
				if (this.position.y >= 50) this.onUpdate = movementTypes.wander;
			}
		};

		o.dire_bat = {
			role: "monster",
			team: 1,
			speed: 150,
			hitPoints: 10,
			damage: 5,
			worth: 0,
			spriteSheet: "characters",
			spriteY: 128,
			animated: true,
			animDelay: 150,
			moveChangeElapsed: 0,
			moveChangeDelay: 500,
			soundDamage: "bat_damage",
			soundDies: "bat_dies",
			
			lootTable: [
				{type: null, weight: 7},
				{type: "item_coin", weight: 3}
			],
			
			onInit: function () {
				this.moveChangeDelay = horde.randomRange(500, 1000);
			},
			onUpdate: function () {
				if (this.position.y >= 50) this.onUpdate = movementTypes.wander;
			}
		};

		o.goblin = {
			role: "monster",
			team: 1,
			speed: 75,
			hitPoints: 10,
			damage: 10,
			worth: 0,
			spriteSheet: "characters",
			spriteY: 160,
			animated: true,
			gibletSize: "medium",
			moveChangeElapsed: 0,
			moveChangeDelay: 3000,
			weapons: [
				{type: "e_arrow", count: null}
			],
			soundAttacks: "goblin_attacks",
			soundDamage: "goblin_damage",
			soundDies: "goblin_dies",
			
			lootTable: [
				{type: null, weight: 6},
				{type: "item_coin", weight: 1},
				{type: "WEAPON_DROP", weight: 2},
				{type: "item_food", weight: 1}
			],
			
			onInit: function () {
				this.moveChangeDelay = horde.randomRange(500, 1000);
			},
			onUpdate: function () {
				if (this.position.y >= 50) this.onUpdate = movementTypes.wanderShoot;
			}
		};

		o.hunter_goblin = {
			role: "monster",
			team: 1,
			speed: 75,
			hitPoints: 10,
			damage: 10,
			worth: 0,
			spriteSheet: "characters",
			spriteY: 160,
			animated: true,
			gibletSize: "medium",
			moveChangeElapsed: 0,
			moveChangeDelay: 3000,
			weapons: [
				{type: "e_arrow", count: null}
			],
			soundAttacks: "goblin_attacks",
			soundDamage: "goblin_damage",
			soundDies: "goblin_dies",
			
			lootTable: [
				{type: null, weight: 2},
				{type: "item_coin", weight: 4},
				{type: "WEAPON_DROP", weight: 2},
				{type: "item_food", weight: 2}
			],
			
			onInit: function () {
				this.moveChangeDelay = horde.randomRange(500, 1000);
			},
			onUpdate: function (elapsed, engine) {
				if (this.position.y >= 50) {
					if (!this.cooldown) {
						this.chase(engine.getPlayerObject());
						return "shoot";
					}
					movementTypes.wander.apply(this, arguments);
				}
			}
		};

		o.demoblin = {
			role: "monster",
			team: 1,
			speed: 75,
			defaultSpeed: 75,
			hitPoints: 30,
			damage: 15,
			worth: 0,
			spriteSheet: "characters",
			spriteY: 192,
			animated: true,
			gibletSize: "medium",
			moveChangeElapsed: 0,
			moveChangeDelay: 3000,
			weapons: [
				{type: "e_trident", count: null}
			],
			
			lootTable: [
				{type: null, weight: 6},
				{type: "WEAPON_DROP", weight: 2},
				{type: "item_chest", weight: 1},
				{type: "item_food", weight: 1}
			],
			
			soundAttacks: "demoblin_attacks",
			soundDamage: "goblin_damage",
			soundDies: "goblin_dies",
			onInit: function () {
				this.moveChangeDelay = horde.randomRange(500, 1000);
				this.cooldown = true;
				this.cooldownElapsed = horde.randomRange(0, 5000);
			},
			onUpdate: function () {
				if (this.position.y >= 50) this.onUpdate = movementTypes.getNear;
			}
		};

		o.flaming_skull = {
			
			role: "monster",
			team: 1,
			
			speed: 200,
			hitPoints: 50,
			damage: 10,
			worth: 0,
			
			spriteSheet: "characters",
			spriteY: 32,
			animated: true,
			
			setDir: false,

			soundDamage: "skull_damage",
			soundDies: "skull_dies",
			
			weapons: [
				{type: "e_static_blue_fire", count: null}
			],
			
			lootTable: [
				{type: null, weight: 6},
				{type: "WEAPON_DROP", weight: 2},
				{type: "item_chest", weight: 2}
			],
			
			onInit: function () {
				switch (horde.randomRange(1, 2)) {
					case 1:
						this.speed *= 0.5;
						this.animDelay *= 0.5;
						break;
					case 2:
						this.speed *= 0.75;
						this.animDelay *= 0.75;
						break;
				}
			},
			
			onUpdate: function (elapsed, engine) {
				if (!this.setDir && this.position.y >= 50) {
					var d = this.direction.clone();
					d.x = Math.random();
					if (Math.random() >= 0.5) {
						d.x *= -1;
					}
					this.setDirection(d);
					this.setDir = true;
				}
				return "shoot";
			}
			
		};

		o.huge_skull = {
			
			role: "monster",
			team: 1,
			badass: true,
			
			speed: 150,
			hitPoints: 200,
			damage: 20,
			worth: 0,
			
			spriteSheet: "characters",
			spriteY: 864,
			animated: true,
			size: new horde.Size(64, 64),
			
			setDir: false,

			soundDamage: "skull_damage",
			soundDies: "skull_dies",
			
			// Clay.io
			achievementId: "killskulls",
			deathsForAchievement: 100,
			
			weapons: [
				{type: "e_static_green_fire", count: null}
			],
			
			lootTable: [
				{type: null, weight: 4},
				{type: "WEAPON_DROP", weight: 3},
				{type: "item_chest", weight: 3}
			],
			
			onInit: function () {
				this.phaseTimer = new horde.Timer();
				switch (horde.randomRange(1, 2)) {
					case 1:
						this.speed *= 0.5;
						this.animDelay *= 0.5;
						break;
					case 2:
						this.speed *= 0.75;
						this.animDelay *= 0.75;
						break;
				}
			},
			
			onUpdate: function (elapsed, engine) {
				switch (this.phase) {
					
					// Come out of the gates
					case 0:
						if (!this.phaseInit) {
							this.phaseInit = true;
						}
						if (this.position.y >= 50) {
							this.nextPhase();
						}
						break;
					
					// Choose a random direction
					case 1:
						if (!this.phaseInit) {
							var d = this.direction.clone();
							d.x = Math.random();
							if (Math.random() >= 0.5) {
								d.x *= -1;
							}
							this.setDirection(d);
							this.phaseTimer.start(horde.randomRange(2000, 4000));
							this.phaseInit = true;
						}
						if (this.phaseTimer.expired()) {
							this.nextPhase();
						}
						break;
					
					// Charge the player just for a half second
					case 2:
						if (!this.phaseInit) {
							this.speed *= 2;
							this.animDelay *= 2;
							this.phaseTimer.start(horde.randomRange(250, 500));
							this.phaseInit = true;
						}
						if (this.phaseTimer.expired()) {
							this.speed /= 2;
							this.animDelay /= 2;
							this.setPhase(1);
						}
						this.chase(engine.getPlayerObject());
						break;
					
				}
				
				return "shoot";

			}
			
		};

		o.spike_wall = {
			
			role: "trap",
			team: 1,
			
			speed: 150,
			hitPoints: Infinity,
			damage: 20,

			spriteSheet: "objects",
			spriteX: 32,
			spriteY: 256,
			drawIndex: 0,
			
			animated: true,
			animNumFrames: 1,
			
			spawnFramesX: 96,
			spawnFramesY: 576,
			spawnFrameCount: 2,
			
			rotate: true,
			rotateSpeed: 0,
			
			onInit: function () {
				this.phaseTimer = new horde.Timer();
				this.spinUpTime = 7500;
				this.wallDirection = new horde.Vector2(0, 1);
				this.addState(horde.Object.states.SPAWNING);
			},
			
			onDamage: function (defender, engine) {
				this.spriteX = 128;
			},
			
			onUpdate: function (elapsed, engine) {
				
				switch (this.phase) {
					
					case 0:
						if (!this.phaseInit) {
							this.phaseTimer.start(this.spinUpTime);
							this.phaseInit = true;
						}
						var step = (this.spinUpTime / 200);
						this.rotateSpeed += ((step / 1000) * elapsed);
						if (this.phaseTimer.expired()) {
							this.nextPhase();
						}
						break;
					
					case 1:
						if (!this.phaseInit) {
							horde.sound.play("spike_attack");
							this.setDirection(this.wallDirection);
							this.phaseInit = true;
						}
						break;
					
				}
				
			},
			
			onWallCollide: function () {
				this.stopMoving();
				this.ttl = 1500;
			}
			
		};

		o.spike_sentry = {
			
			role: "trap",
			team: 1,
			
			speed: 100,
			hitPoints: Infinity,
			damage: 10,
			worth: 0,
			
			spriteSheet: "objects",
			spriteX: 64,
			spriteY: 256,
			
			animated: true,
			animNumFrames: 1,
			
			spawnFramesX: 0,
			spawnFramesY: 576,
			spawnFrameCount: 2,
			
			rotate: true,
			rotateSpeed: 100,

			phase: 0,
			phaseInit: false,
			
			onInit: function () {
				this.addState(horde.Object.states.SPAWNING);
			},
			
			onDamage: function (defender, engine) {

				if (defender.role === "hero") {
					this.spriteX = 160;
				}
				
			},
			
			onUpdate: function (elapsed, engine) {
				
				if (this.hasState(horde.Object.states.SPAWNING)) {
					return;
				}
				
				switch (this.phase) {
					
					// Wait for player to get near X or Y axis
					case 0:
						if (!this.phaseInit) {
							this.stopMoving();
							this.phaseInit = true;
						}
						var p = engine.getPlayerObject();
						var diff = p.position.clone().subtract(this.position);
						if (Math.abs(diff.y) < 32) {
							// charge the player along the left/right axis
							this.originalPos = this.position.clone();
							var d = new horde.Vector2();
							d.x = (diff.x < 0) ? -1: 1;
							this.setDirection(d);
							this.phase++;
							this.phaseInit = false;
							horde.sound.play("spike_attack");
						} else if (Math.abs(diff.x) < 32) {
							this.originalPos = this.position.clone();
							var d = new horde.Vector2();
							d.y = (diff.y < 0) ? -1: 1;
							this.setDirection(d);
							this.phase++;
							this.phaseInit = false;
							horde.sound.play("spike_attack");
						}
						break;
						
					// Charging the player
					case 1:
						if (!this.phaseInit) {
							this.speed = 300;
							this.rotateSpeed = 300;
							this.phaseInit = true;
						}
						var diff = this.position.clone().subtract(this.originalPos).abs();
						if (diff.x > 320 - 64) {
							var d = this.direction.clone();
							d.x *= -1;
							this.setDirection(d);
							this.phase++;
							this.phaseInit = false;
						} else if (diff.y > 240 - (4 *32) + 16) {
							var d = this.direction.clone();
							d.y *= -1;
							this.setDirection(d);
							this.phase++;
							this.phaseInit = false;
						}
						break;
					
					// Reseting
					case 2:
						if (!this.phaseInit) {
							this.speed = 50;
							this.rotateSpeed = 100;
							this.phaseInit = true;
						}
						var diff = this.position.clone().subtract(this.originalPos).abs();
						if (diff.x < 5 && diff.y < 5) {
							this.stopMoving();
							this.position = this.originalPos.clone();
							this.phase = 0;
							this.phaseInit = false;
						}
						break;

				}

			}

		};

		o.spikes = {

			role: "trap",
			team: 1,

			speed: 0,
			hitPoints: Infinity,
			damage: 10,
			worth: 0,

			spriteSheet: "objects",
			spriteX: 0,
			spriteY: 256,

			animated: true,
			animNumFrames: 1,

			spawnFramesX: 224,
			spawnFramesY: 256,
			spawnFrameCount: 3,

			collidable: false,

			onInit: function () {
				this.addState(horde.Object.states.SPAWNING);
			},

			onDamage: function (defender, engine) {
				if (defender.role === "hero") {
					this.spriteX = 96;
				}
			}

		};

		o.owlbear = {
			role: "monster",
			team: 1,
			badass: true,
			
			animated: true,
			size: new horde.Size(64, 64),
			spriteSheet: "characters",
			spriteY: 800,
			
			damage: 15,
			hitPoints: 250,
			speed: 75,

			soundAlarm: "owlbear_alarm",
			soundAttacks: "owlbear_attacks",
			soundDamage: "owlbear_damage",
			soundDies: "owlbear_dies",
			
			// Clay.io
			achievementId: "killowlbears",
			deathsForAchievement: 100,
			
			lootTable: [
				{type: "item_food", weight: 1}
			],
			
			onInit: function () {
				this.moveChangeDelay = horde.randomRange(500, 1000);
				this.phaseTimer = new horde.Timer();
			},
			
			onUpdate: function (elapsed, engine) {
				switch (this.phase) {
				
					// Charge out of the gates
					case 0:
						if (!this.phaseInit) {
							this.speed = 150;
							this.animDelay = 150;
							this.phaseInit = true;
						}
						if (this.position.y >= 60) {
							this.nextPhase();
						}
						break;
					
					// Wander around, slowly
					case 1:
						if (!this.phaseInit) {
							this.speed = 75;
							this.animDelay = 300;
							this.phaseInit = true;
						}
						movementTypes.wander.apply(this, arguments);
						var player = engine.getPlayerObject();
						var diff = player.position.clone().subtract(this.position).abs();
						if (diff.x < (this.size.width / 2) || diff.y < (this.size.height / 2)) {
							this.chase(player);
							this.nextPhase();
						}
						break;
					
					// Spotted the player, prepare to charge	
					case 2:
						if (!this.phaseInit) {
							horde.sound.play(this.soundAlarm);
							this.speed = 0;
							this.animDelay = 150;
							this.phaseTimer.start(500);
							this.phaseInit = true;
						}
						this.position.x += horde.randomRange(-1, 1);
						if (this.phaseTimer.expired()) {
							this.nextPhase();
						}
						break;
						
					// Charge!
					case 3:
						if (!this.phaseInit) {
							horde.sound.play(this.soundAttacks);
							this.speed = 350;
							this.animDelay = 75;
							this.phaseTimer.start(2000);
							this.phaseInit = true;
						}
						if (this.phaseTimer.expired()) {
							this.nextPhase();
						}
						break;
					
					// Stunned for bit
					case 4:
						if (!this.phaseInit) {
							this.stopMoving();
							this.animDelay = 400;
							this.phaseTimer.start(1250);
							this.phaseInit = true;
						}
						if (this.phaseTimer.expired()) {
							this.setPhase(1);
						}
						break;
					
				}
			}
			
		};

		o.cyclops = {
			role: "monster",
			team: 1,
			badass: true,

			animated: true,
			gibletSize: "large",
			size: new horde.Size(64, 64),
			spriteSheet: "characters",
			spriteY: 224,

			moveChangeElapsed: 0,
			moveChangeDelay: 1000,

			damage: 20,
			hitPoints: 200,
			speed: 100,
			animDelay: 100,
			worth: 0,

			soundAttacks: "cyclops_attacks",
			soundDamage: "cyclops_damage",
			soundDies: "cyclops_dies",

			weapons: [{type: "e_boulder", count: null}],

			lootTable: [
				{type: "item_food", weight: 7},
				{type: "WEAPON_DROP", weight: 3}
			],

			onInit: function () {
				this.moveChangeDelay = horde.randomRange(500, 1000);
				this.setDirection(horde.directions.toVector(horde.directions.DOWN));
			},
			onUpdate: function (elapsed, engine) {
				if (this.position.y >= 50) {
					this.speed = 25;
					this.animDelay = 200;
					this.onUpdate = movementTypes.chase;
				}
			}
		};

		// Beholder eyelets
		o.eyelet = {
			role: "monster",
			team: 1,
			
			animated: true,
			spriteSheet: "characters",
			spriteY: 512,
			
			damage: 10,
			hitPoints: 40,
			speed: 100,

			soundDamage: "eyelet_damage",
			soundDies: "eyelet_dies",
			
			collidable: false,

			lootTable: [
				{type: null, weight: 9},
				{type: "item_food", weight: 1},
				{type: "WEAPON_DROP", weight: 8},
				{type: "item_weapon_fireball", weight: 2}
			],
			
			makeBadass: function () {
				this.spriteY = 960;
				this.hitPoints = 50;
				this.speed = 150;
				this.damage = 20;
			},
			
			onInit: function () {
				if (horde.randomRange(1, 10) > 5) {
					this.spriteY += 32;
				}
				this.ownerAngle = 0;
				this.phaseTimer = new horde.Timer();
				this.addState(horde.Object.states.INVINCIBLE, 1000);
			},
			
			onUpdate: function (elapsed, engine) {

				if (!engine.objects[this.ownerId]) {
					this.wound(this.hitPoints);
					return;
				}

				switch (this.phase) {
					
					// Snap to the north of the owner
					case 0:
						if (!this.phaseInit) {
							this.phaseTimer.start(10000);
							this.phaseInit = true;
						}
						var owner = engine.objects[this.ownerId];
						var ownerCenter = owner.position.clone().add(
							horde.Vector2.fromSize(owner.size).scale(0.5)
						).subtract(new horde.Vector2(10, 10));
						var d = horde.Vector2.fromHeading(this.ownerAngle);
						this.position = ownerCenter.add(d.scale(owner.eyeletOffset));
						this.ownerAngle += ((1.05 / 1000) * elapsed);
						if (this.ownerAngle > (Math.PI * 2)) {
							this.ownerAngle = 0;
						}
						if (
							this.phaseTimer.expired() 
							&& engine.checkTileCollision(this) === false
						) {
							this.nextPhase();
						}
						break;
						
					case 1:
						if (!this.phaseInit) {
							this.collidable = true;
							this.speed = 175;
							this.phaseInit = true;
						}
						movementTypes.wander.apply(this, arguments);
						break;
					
				}
			}
			
		};

		o.cube = {
			role: "monster",
			team: 1,
			badass: true,

			animated: true,
			animDelay: 400,
			gibletSize: "large",
			size: new horde.Size(64, 64),
			spriteSheet: "characters",
			spriteY: 576,

			moveChangeElapsed: 0,
			moveChangeDelay: 1000,

			damage: 35,
			hitPoints: 750,
			speed: 15,
			worth: 0,
			
			soundAttacks: "cube_attacks",
			soundDamage: "cube_damage",
			soundDies: "cube_dies",
			
			// Clay.io
			achievementId: "defeatgel",
			deathsForAchievement: 1,

		/*
			lootTable: [
				{type: "item_chest", weight: 1},
				{type: "WEAPON_DROP", weight: 6},
				{type: "item_food", weight: 3}
			],
			*/
			lootTable: [
				{type: "item_gold_chest", weight: 1}
			],

			onInit: function () {
				this.moveChangeDelay = horde.randomRange(500, 1000);
				this.setDirection(horde.directions.toVector(horde.directions.DOWN));
				this.phaseTimer = new horde.Timer();
				this.gelTimer = new horde.Timer();
			},
			
			onThreat: function (attacker, engine) {
				if (attacker.damageType !== "magic") {
					return true;
				}
			},
			
			onUpdate: function (elapsed, engine) {
				
				this.gelTimer.update(elapsed);
				
				switch (this.phase) {
					
					// "Charge" out of gate
					case 0:
						if (!this.phaseInit) {
							this.speed = 100;
							this.animDelay = 200;
							this.phaseInit = true;
						}
						if (this.position.y >= 150) {
							this.nextPhase();
						}
						break;
					
					// Spawn a bunch of gels!
					case 1:
						if (!this.phaseInit) {
							this.stopMoving();
							this.speed = 15;
							this.animDelay = 400;
							this.phaseTimer.start(6000);
							this.gelTimer.start(300);
							this.phaseInit = true;
						}
						if (this.phaseTimer.expired()) {
							this.nextPhase();
							break;
						}
						movementTypes.wander.apply(this, arguments);
						//this.chase(engine.getPlayerObject());
						this.position.x += horde.randomRange(-1, 1);
						if (this.gelTimer.expired()) {
							engine.spawnObject(this, "gel");
							horde.sound.play(this.soundAttacks);
							this.gelTimer.reset();
						}
						break;
					
					case 2:
						if (!this.phaseInit) {
							this.speed = 30;
							this.animDelay = 150;
							this.phaseTimer.start(7500);
							this.phaseInit = true;
						}
						if (this.phaseTimer.expired()) {
							this.setPhase(1);
							break;
						}
						movementTypes.chase.apply(this, arguments);
						break;
					
				}
				
			}
		};

		o.gel = {
			role: "monster",
			team: 1,

			animated: true,
			animDelay: 400,
			
			spriteSheet: "characters",
			spriteY: 640,

			moveChangeElapsed: 0,
			moveChangeDelay: 1000,

			damage: 5,
			hitPoints: 10,
			speed: 150,
			worth: 0,

			soundDamage: "gel_damage",
			soundDies: "gel_dies",

			onInit: function () {
				this.setDirection(horde.randomDirection());
				this.moveChangeDelay = horde.randomRange(500, 1000);
				// Randomize sprite
				switch (horde.randomRange(1, 4)) {
					case 1: this.spriteY = 640; break;
					case 2: this.spriteY = 672; break;
					case 3: this.spriteY = 704; break;
					case 4: this.spriteY = 736; break;
				}
			},
			
			onUpdate: function (elapsed, engine) {
				movementTypes.wander.apply(this, arguments);
			},
			
			onKilled: function (attacker, engine) {
				var player = engine.getPlayerObject();
				// Spawn a fireball scroll if the player is out
				// AND there aren't any on the screen
				if (
					!player.hasWeapon("h_fireball")
					&& !player.hasWeapon("h_fire_sword")
					&& engine.getObjectCountByType("item_weapon_fireball") === 0
				) {
					engine.dropObject(this, "item_weapon_fireball");
				}
			}
			
		};

		o.superclops = {
			role: "monster",
			team: 1,
			badass: true,

			animated: true,
			gibletSize: "large",
			size: new horde.Size(64, 64),
			spriteSheet: "characters",
			spriteY: 288,

			moveChangeElapsed: 0,
			moveChangeDelay: 1000,

			damage: 20,
			hitPoints: 750,
			speed: 25,
			worth: 0,

			soundAttacks: "minotaur_attacks",
			soundDamage: "minotaur_damage",
			soundDies: "minotaur_dies",
			
			// Clay.io
			achievementId: "defeatminotaur",
			deathsForAchievement: 1,

			weapons: [{type: "e_minotaur_trident", count: null}],

			lootTable: [
				{type: "item_gold_chest", weight: 1}
			],

			onInit: function () {
				this.phaseTimer = new horde.Timer();
				this.moveChangeDelay = horde.randomRange(500, 1000);
				this.setDirection(horde.directions.toVector(horde.directions.DOWN));
			},
			onUpdate: function (elapsed, engine) {
				
				switch (this.phase) {
					
					// Charge out of the gates
					case 0:
						if (!this.phaseInit) {
							this.speed = 200;
							this.animDelay = 100;
							this.phaseInit = true;
						}
						if (this.position.y >= 80) {
							this.nextPhase();
						}
						break;
					
					// Shoot two boulders
					case 1:
						if (!this.phaseInit) {
							this.animDelay = 250;
							var p = engine.getPlayerObject();
							this.chase(p);
							this.stopMoving();
							var h = this.facing.heading();
							engine.spawnObject(this, "e_bouncing_boulder", horde.Vector2.fromHeading(
								h - 0.3
							));
							engine.spawnObject(this, "e_bouncing_boulder", horde.Vector2.fromHeading(
								h + 0.3
							));
							this.phaseTimer.start(1500);
							this.phaseInit = true;
						}
						if (this.phaseTimer.expired()) {
							this.nextPhase();
						}
						break;
						
					// Charge down the middle
					case 2:
						if (!this.phaseInit) {
							this.speed = 300;
							this.animDelay = 100;
							this.setDirection(this.facing);
							this.phaseTimer.start(2000);
							this.phaseInit = true;
						}
						if (this.phaseTimer.expired()) {
							this.nextPhase();
						}
						break;
					
					// Wander a bit as if stunned by the charge
					case 3:
						if (!this.phaseInit) {
							this.speed = 15;
							this.animDelay = 400;
							this.phaseTimer.start(2000);
							this.phaseInit = true;
						}
						movementTypes.wander.apply(this, arguments);
						if (this.phaseTimer.expired()) {
							if (this.wounds > (this.hitPoints / 2)) {
								this.nextPhase();
							} else {
								this.setPhase(1);
							}
						}
						break;
					
					// Wiggle!
					case 4:
						if (!this.phaseInit) {
							this.stopMoving();
							this.animDelay = 300;
							this.phaseTimer.start(1500);
							this.phaseInit = true;
						}
						if (this.phaseTimer.expired()) {
							this.nextPhase();
							break;
						}
						this.position.x += horde.randomRange(-1, 1);
						break;
					
					// Shoot bouncing boulders
					case 5:
						if (!this.phaseInit) {
							this.cooldown = false;
							this.weapons = [{type: "e_bouncing_boulder", count: null}];
							this.phaseInit = true;
						}
						engine.objectAttack(this);
						this.position.x += horde.randomRange(-1, 1);
						this.nextPhase();
						break;
					
					// Chase and shoot tridents
					case 6:
						if (!this.phaseInit) {
							this.speed = 50;
							this.weapons = [{type: "e_minotaur_trident", count: null}];
							this.cooldown = true;
							this.phaseTimer.start(6000)
							this.phaseInit = true;
						}
						if (this.phaseTimer.expired()) {
							this.setPhase(4);
						}
						engine.objectAttack(this);
						movementTypes.chase.apply(this, arguments);
						break;

				}
				
			},
			
			onWallCollide: function () {
				if (this.phase === 2) {
					this.nextPhase();
				}
			}

		};

		o.imp = {

			role: "monster",
			team: 1,

			speed: 100,

			hitPoints: 20,
			damage: 15,

			worth: 0,

			spriteSheet: "characters",
			spriteY: 64,
			animated: true,

			gibletSize: "medium",

			moveChangeElapsed: 0,
			moveChangeDelay: 3000,

			soundDamage: "imp_damage",
			soundDies: "imp_dies",

			phase: 0,
			phaseInit: false,

			lootTable: [
				{type: null, weight: 7},
				{type: "item_food", weight: 1},
				{type: "WEAPON_DROP", weight: 2}
			],

			onInit: function () {
				this.phaseTimer = new horde.Timer();
				this.moveChangeDelay = horde.randomRange(500, 1000);
			},

			onKilled: function (attacker, engine) {
				if (attacker.role === "projectile") {
					attacker.die();
				}
				for (var x = 0; x < 2; ++x) {
					engine.spawnObject(
						this,
						"dire_bat",
						horde.randomDirection(),
						false
					);
				}
			},

			onUpdate: function (elapsed, engine) {

				switch (this.phase) {

					// Move past the gates
					case 0:
						if (!this.phaseInit) {
							this.phaseInit = true;
						}
						if (this.position.y >= 50) {
							this.phase++;
							this.phaseInit = false;
						}
						break;

					// Wander slowly
					case 1:
						if (!this.phaseInit) {
							this.speed = 50;
							this.animDelay = 400;
							this.phaseTimer.start(2500, 7500);
							this.phaseInit = true;
						}
						movementTypes.wander.apply(this, arguments);
						if (this.phaseTimer.expired()) {
							this.phase++;
							this.phaseInit = false;
						}
						break;

					// Wander fast!
					case 2:
						if (!this.phaseInit) {
							this.speed = 150;
							this.animDelay = 150;
							this.phaseTimer.start(2500, 7500);
							this.phaseInit = true;
						}
						movementTypes.wander.apply(this. arguments);
						if (this.phaseTimer.expired()) {
							this.phase = 1;
							this.phaseInit = false;
						}
						break;

				}

			}
		};

		o.wizard = {
			role: "monster",
			team: 1,
			speed: 100,
			hitPoints: 20,
			damage: 10,
			worth: 0,
			spriteSheet: "characters",
			spriteY: 416,
			animated: true,
			gibletSize: "medium",
			moveChangeElapsed: 0,
			moveChangeDelay: 3000,

			weapons: [
				{type: "e_shock_wave", count: null}
			],

			soundAttacks: "wizard_attacks",
			soundDisappear: "wizard_disappear",
			soundReappear: "wizard_reappear",
			soundDamage: "goblin_damage",
			soundDies: "goblin_dies",

			lootTable: [
				{type: null, weight: 6},
				{type: "item_chest", weight: 2},
				{type: "WEAPON_DROP", weight: 2}
			],

			phase: 0,
			phaseInit: false,

			onInit: function () {
				this.phaseTimer = new horde.Timer();
				this.moveChangeDelay = horde.randomRange(500, 1000);
				this.moveToY = horde.randomRange(50, 75);
			},
			onUpdate: function (elapsed, engine) {

				switch (this.phase) {

					// Move out of the gates
					case 0:
						if (!this.phaseInit) {
							this.phaseInit = true;
						}
						if (this.position.y >= this.moveToY) {
							this.phase++;
							this.phaseInit = false;
						}
						break;

					// Phase out
					case 1:
						if (!this.phaseInit) {
							this.animated = false;
							this.stopMoving();
							this.addState(horde.Object.states.INVINCIBLE);
							this.phaseTimer.start(1000);
							this.phaseInit = true;
							horde.sound.play(this.soundDisappear);
						}
						if (this.phaseTimer.expired()) {
							this.phase++;
							this.phaseInit = false;
						}
						break;

					// Turn invisible and move around!
					case 2:
						if (!this.phaseInit) {
							this.speed = 500;
							this.addState(horde.Object.states.INVISIBLE);
							this.phaseTimer.start(horde.randomRange(1000, 2000));
							this.phaseInit = true;
						}
						// Don't trigger phase in if wizard is too close to the player
						var myCenter = this.boundingBox().center();
						var playerCenter = engine.getPlayerObject().boundingBox().center();
						var diff = playerCenter.clone().subtract(myCenter).abs();
						movementTypes.wander.apply(this, arguments);
						if (this.phaseTimer.expired() && diff.magnitude() > 90) {
							this.phase++;
							this.phaseInit = false;
						}
						break;

					// Phase in
					case 3:
						if (!this.phaseInit) {
							this.stopMoving();
							this.removeState(horde.Object.states.INVISIBLE);
							this.phaseTimer.start(1000);
							this.phaseInit = true;
							horde.sound.play(this.soundReappear);
						}
						if (this.phaseTimer.expired()) {
							this.phase++;
							this.phaseInit = false;
						}
						break;

					// Shoot the player!
					case 4:
						if (!this.phaseInit) {
							this.speed = 0;
							this.animated = true;
							this.removeState(horde.Object.states.INVINCIBLE);
							this.phaseTimer.start(horde.randomRange(2000, 3000));
							this.phaseInit = true;
							this.shotOnce = false;
						}
						var p = engine.getPlayerObject();
						this.chase(p);
						if (this.phaseTimer.expired()) {
							this.phase = 1;
							this.phaseInit = false;
						}
						if (!this.shotOnce) {
							this.shotOnce = true;
							return "shoot";
						}
						break;

				}

			}
		};

		o.sandworm = {

			role: "monster",
			team: 1,

			animated: true,
			animDelay: 200,
			spriteSheet: "characters",
			spriteY: 480,
			
			spawnFramesX: 544,
			spawnFramesY: 448,
			spawnFrameCount: 2,
			
			damage: 25,
			hitPoints: 50,
			speed: 50,
			worth: 0,
			
			phase: 0,
			phaseInit: false,
			
			moveChangeElapsed: 0,
			moveChangeDelay: 2000,

			soundAttacks: "sandworm_attacks",
			soundDamage: "goblin_damage",
			soundDies: "sandworm_dies",

			lootTable: [
				{type: null, weight: 4},
				{type: "item_chest", weight: 2},
				{type: "WEAPON_DROP", weight: 2},
				{type: "item_food", weight: 2}
			],
			
			onInit: function () {
				this.phaseTimer = new horde.Timer();
				this.dirtTimer = new horde.Timer();
				this.attackTimer = new horde.Timer();
			},
			
			onUpdate: function (elapsed, engine) {
				switch (this.phase) {
									
					case 0:
						if (!this.phaseInit) {
							this.speed = 50;
							this.addState(horde.Object.states.INVISIBLE);
							this.phaseTimer.start(horde.randomRange(5000, 10000));
							this.dirtTimer.start(150);
							this.phaseInit = true;
						}
						this.dirtTimer.update(elapsed);
						if (this.position.y <= 50) {
							this.setDirection(horde.directions.toVector(horde.directions.DOWN));
						} else {
							movementTypes.wander.apply(this, arguments);
						}
						if (this.phaseTimer.expired()) {
							this.phase++;
							this.phaseInit = false;
						}
						if (this.dirtTimer.expired()) {
							engine.spawnObject(this, "e_dirt_pile");
							this.dirtTimer.reset();
						}
						break;
						
					case 1:
						// spawn!
						if (!this.phaseInit) {
							this.stopMoving();
							this.speed = 0;
							this.removeState(horde.Object.states.INVISIBLE);
							this.addState(horde.Object.states.SPAWNING);
							this.spawnFrameIndex = 0;
							this.phaseInit = true;
						}
						if (!this.hasState(horde.Object.states.SPAWNING)) {
							this.phase++;
							this.phaseInit = false;
						}
						break;
						
					case 2:
						// fire globs of shit
						if (!this.phaseInit) {
							this.phaseAttacks = 0;
							this.phaseInit = true;
							this.attackTimer.start(200);
						}
						this.attackTimer.update(elapsed);
						if (this.phaseAttacks < 1 && this.attackTimer.expired()) {
							this.phaseAttacks++;
							//this.chase(engine.getPlayerObject());
							this.setDirection(horde.randomDirection());
							engine.spawnObject(this, "e_worm_spit");
							horde.sound.play(this.soundAttacks);
							this.attackTimer.reset();
							if (this.phaseAttacks === 1) {
								this.phaseTimer.start(2000);
							}
						}
						if (this.phaseAttacks >= 1 && this.phaseTimer.expired()) {
							this.phase++;
							this.phaseInit = false;
						}
						break;
						
					case 3:
						// burrow!
						if (!this.phaseInit) {
							this.addState(horde.Object.states.DESPAWNING);
							this.spawnFrameIndex = 2;
							this.phaseInit = true;
						}
						if (!this.hasState(horde.Object.states.DESPAWNING)) {
							this.addState(horde.Object.states.INVISIBLE);
							this.phase = 0;
							this.phaseInit = false;
						}
						break;

				}
			}
			
		};

		o.doppelganger = {
			role: "monster",
			team: 1,
			badass: true,

			animated: true,
			spriteSheet: "characters",
			spriteY: 0,
			spriteY: 768,
			spriteYOverlay: 928,

			damage: 20,
			hitPoints: 5000,
			speed: 200,

			soundAttacks: "dopp_attacks",
			soundDamage: "dopp_damage",
			soundDies: "dopp_dies",
			
			// Clay.io
			achievementId: "defeatdoppelganger",
			deathsForAchievement: 1,

			onInit: function () {
				this.phaseTimer = new horde.Timer();
			},

			onKilled: function (attacker, engine) {
				for (var id in engine.objects) {
					var obj = engine.objects[id];
					if (obj.role === "monster" && obj.id !== this.id) {
						obj.wound(obj.hitPoints);
					} else if (obj.role === "trap") {
						obj.ttl = 1500;
					}
				}
			},

			onUpdate: function (elapsed, engine) {

				switch (this.phase) {

					// Charge out of the gates
					case 0:
						if (!this.phaseInit) {
							this.speed = 300;
							this.animDelay = 100;
							this.phaseInit = true;
						}
						if (this.position.y > 100) {
							this.nextPhase();
						}
						break;

					// Dash to first waypoint
					case 1:
						if (!this.phaseInit) {
							this.speed = 200;
							this.animDelay = 200;
							this.waypoints = this.getPattern();
							this.currentWaypoint = this.waypoints.shift();
							this.phaseInit = true;
						}
						this.moveToward(this.currentWaypoint);
						var diff = this.currentWaypoint.clone().subtract(this.position).abs().magnitude();
						if (diff < 10) {
							this.position = this.currentWaypoint.clone();
							this.nextPhase();
						}
						break;

					// Shake
					case 2:
						if (!this.phaseInit) {
							this.setDirection(new horde.Vector2(0, 1));
							this.stopMoving();
							this.phaseTimer.start(500);
							this.phaseInit = true;
						}
						this.position.x += horde.randomRange(-1, 1);
						if (this.phaseTimer.expired()) {
							this.nextPhase();
						}
						break;

					// Follow waypoints dropping spikes
					case 3:
						if (!this.phaseInit) {
							this.currentWaypoint = this.waypoints.shift();
							this.speed = 400;
							this.animDelay = 100;
							this.phaseInit = true;
							this.spikeTimer = new horde.Timer();
							this.spikeTimer.start(200);
						}
						this.spikeTimer.update(elapsed);
						if (this.spikeTimer.expired()) {
							horde.sound.play("spike_attack");
							var id = engine.spawnObject(this, "spikes");
							var o = engine.objects[id];
							if (o) {
								o.ttl = 10000;
							}
							this.spikeTimer.reset();
						}
						this.moveToward(this.currentWaypoint);
						var diff = this.currentWaypoint.clone().subtract(this.position).abs().magnitude();
						if (diff < 10) {
							this.position = this.currentWaypoint.clone();
							if (this.waypoints.length > 0) {
								this.currentWaypoint = this.waypoints.shift();
							} else {
								this.nextPhase();
							}
						}
						break;

					// Chase hero slowly
					case 4:
						if (!this.phaseInit) {
							this.speed = 100;
							this.animDelay = 200;
							this.phaseTimer.start(7500);
							this.phaseInit = true;
						}
						var player = engine.getPlayerObject();
						if (player.wounds < player.hitPoints) {
							this.chase(player);
						}
						// TODO: Shoot swords
						if (this.phaseTimer.expired()) {
							this.nextPhase();
						}
						break;

					// Dash to upper left
					case 5:
						if (!this.phaseInit) {
							this.speed = 200;
							this.animDelay = 200;
							this.phaseInit = true;
							this.targetPos = new horde.Vector2(32, 66);
						}
						this.moveToward(this.targetPos);
						var diff = this.targetPos.clone().subtract(this.position).abs().magnitude();
						if (diff < 10) {
							this.position = this.targetPos.clone();
							this.nextPhase();
						}
						break;

					// Summon spike walls and shoot spears
					case 6:
						if (!this.phaseInit) {
							this.setDirection(new horde.Vector2(0, 1));
							this.stopMoving();
							this.phaseInit = true;
							this.makeSpikeWalls(engine);
							this.weapons = [{type: "e_dopp_sword", count: null}];
						}
						if (this.phaseTimer.expired()) {
							this.nextPhase();
						}
						this.chase(engine.getPlayerObject());
						this.stopMoving();
						if (this.wounds > (this.hitPoints * 0.33)) {
							// 2/3 HP (or lower)
							return "shoot";
						}
						break;

					// Chill out for a bit
					case 7:
						if (!this.phaseInit) {
							this.stopMoving();
							this.phaseTimer.start(4000);
							this.phaseInit = true;
						}
						if (this.phaseTimer.expired()) {
							// Poop out a meat...
							var meat = horde.makeObject("item_food");
							meat.position.x = 32;
							meat.position.y = 64;
							engine.addObject(meat);
							this.nextPhase();
						}
						break;

					// Wander throwing battle axes
					case 8:
						if (!this.phaseInit) {
							this.speed = 200;
							this.animDelay = 200;
							this.weapons = [{type: "e_dopp_axe", count: null}];
							this.cooldown = false;
							this.waypoints = this.getPattern();
							this.currentWaypoint = this.waypoints.shift();
							this.axeTimer = new horde.Timer();
							this.axeTimer.start(3000);
							this.axeTimer.update(3000);
							this.phaseInit = true;
						}
						this.axeTimer.update(elapsed);
						if (this.axeTimer.expired()) {
							this.chase(engine.getPlayerObject());
							engine.spawnObject(this, "e_dopp_axe");
							this.axeTimer.reset();
						}
						this.moveToward(this.currentWaypoint);
						var diff = this.currentWaypoint.clone().subtract(this.position).abs().magnitude();
						if (diff < 10) {
							this.position = this.currentWaypoint.clone();
							if (this.waypoints.length > 0) {
								this.currentWaypoint = this.waypoints.shift();
							} else {
								this.nextPhase();
							}
						}
						break;

					// Dash to center
					case 9:
						if (!this.phaseInit) {
							this.speed = 200;
							this.animDelay = 200;
							this.phaseInit = true;
							this.targetPos = new horde.Vector2((640 / 2) - 16, (480 / 2) - 16);
						}
						this.moveToward(this.targetPos);
						var diff = this.targetPos.clone().subtract(this.position).abs().magnitude();
						if (diff < 10) {
							this.position = this.targetPos.clone();
							this.nextPhase();
						}
						break;

					// Spawn some shit...
					case 10:
						if (!this.phaseInit) {
							horde.sound.play("minotaur_dies");
							this.setDirection(new horde.Vector2(0, 1));
							this.stopMoving();
							this.phaseInit = true;
							for (var b = 0; b < 60; ++b) {
								var id = engine.spawnObject(this, "dire_bat");
								var o = engine.objects[id];
								o.setDirection(horde.randomDirection());
								o.addState(horde.Object.states.INVINCIBLE, 250);
							}
							this.phaseTimer.start(8000);
						}
						if (this.phaseTimer.expired()) {
							this.setPhase(1);
						}
						break;

				}

			},

			getPattern: function () {
				switch (horde.randomRange(1, 3)) {

					// Spiral
					case 1:
						return [
							new horde.Vector2(64, 320),
							new horde.Vector2(64, 96),
							new horde.Vector2(544, 96),
							new horde.Vector2(544, 320),
							new horde.Vector2(128, 320),
							new horde.Vector2(128, 160),
							new horde.Vector2(480, 160),
							new horde.Vector2(480, 256),
							new horde.Vector2(192, 256)
						];
						break;
					
					// Snake
					case 2:
						return [
							new horde.Vector2(576, 352),
							new horde.Vector2(32, 352),
							new horde.Vector2(32, 288),
							new horde.Vector2(576, 288),
							new horde.Vector2(576, 224),
							new horde.Vector2(32, 224),
							new horde.Vector2(32, 160),
							new horde.Vector2(576, 160),
							new horde.Vector2(576, 96),
							new horde.Vector2(32, 96)
						];
						break;

					// Hourglass
					case 3:
						return [
							new horde.Vector2(576, 64),
							new horde.Vector2(32, 64),
							new horde.Vector2(288, 192),
							new horde.Vector2(32, 352),
							new horde.Vector2(576, 352),
							new horde.Vector2(352, 224),
							new horde.Vector2(576, 64)
						];
						break;

				}
			},

			makeSpikeWalls: function (engine) {

				horde.sound.play("wizard_reappear");

				var safeSpots = 3;
				var spinUpTime = 5000;
				var wallSpeedMod = 2;

				if (this.wounds > (this.hitPoints * 0.66)) {
					// 1/3 HP (or lower)
					safeSpots = 1;
					spinUpTime = 5000;
					wallSpeedMod = 2;
				} else if (this.wounds > (this.hitPoints * 0.33)) {
					// 2/3 HP (or lower)
					safeSpots = 2;
					spinUpTime = 7500;
					wallSpeedMod = 1.5;
				}

				this.phaseTimer.start(spinUpTime - 1500);

				// Make top wall
				var spike = [];
				for (var a = 0; a < 18; ++a) {
					spike.push(true);
				}

				for (var j = 0; j < safeSpots; ++j) {
					var c = 0;
					var found = false;
					while (found === false) {
						c = horde.randomRange(3, (spike.length - 1));
						found = (spike[c] === true);
					}
					spike[c] = false;
				}

				for (var x = 0; x < spike.length; ++x) {
					if (spike[x] === true) {
						var obj = horde.makeObject("spike_wall");
						obj.position = new horde.Vector2(32 + (x * 32), 64);
						obj.spinUpTime = spinUpTime;
						obj.speed *= wallSpeedMod;
						engine.addObject(obj);
					}
				}

				// Make left wall
				var spike = [];
				for (var a = 0; a < 10; ++a) {
					spike.push(true);
				}

				for (var j = 0; j < safeSpots; ++j) {
					var c = 0;
					var found = false;
					while (found === false) {
						c = horde.randomRange(3, (spike.length - 1));
						found = (spike[c] === true);
					}
					spike[c] = false;
				}

				for (var x = 0; x < spike.length; ++x) {
					if (spike[x] === true) {
						var obj = horde.makeObject("spike_wall");
						obj.position = new horde.Vector2(32, 64 + (x * 32));
						obj.wallDirection = new horde.Vector2(1, 0);
						obj.spinUpTime = spinUpTime;
						obj.speed = 275; // More ground to cover
						obj.speed *= wallSpeedMod;
						engine.addObject(obj);
					}
				}	

			}

		};

		o.e_dopp_axe = {
			role: "projectile",
			cooldown: 2500,
			speed: 250,
			hitPoints: Infinity,
			damage: 15,
			spriteSheet: "objects",
			spriteX: 160,
			spriteY: 32,
			rotate: true,
			rotateSpeed: 700,
			priority: 5,
			ttl: 10000,
			soundAttacks: "dopp_attacks",

			onInit: function () {
				this.spawnTimer = new horde.Timer();
				this.spawnTimer.start(50);
			},

			onUpdate: function (elapsed, engine) {
				if (!engine.objectExists(this.ownerId)) {
					this.die();
				}
				this.spawnTimer.update(elapsed);
				if (this.spawnTimer.expired()) {
					engine.spawnObject(this, "e_dopp_fire");
					this.spawnTimer.reset();
				}
			},
			// Clay.io
			ignoreLogDeath: true
		};

		o.e_dopp_sword = {
			role: "projectile",
			cooldown: 750,
			speed: 350,
			hitPoints: Infinity,
			damage: 5,
			spriteSheet: "objects",
			spriteX: 384,
			spriteY: 544,
			spriteAlign: true,
			priority: 2,
			bounce: false,
			piercing: true,
			soundAttacks: "dopp_attacks",

			onInit: function () {
				this.spawnTimer = new horde.Timer();
				this.spawnTimer.start(50);
			},
			
			onUpdate: function (elapsed, engine) {
				this.spawnTimer.update(elapsed);
				if (this.spawnTimer.expired()) {
					engine.spawnObject(this, "e_dopp_fire");
					this.spawnTimer.reset();
				}
			},
			// Clay.io
			ignoreLogDeath: true
		};

		o.beholder = {
			role: "monster",
			team: 1,
			badass: true,

			size: new horde.Size(128, 128),
			spriteSheet: "beholder",
			animated: true,
			animDelay: 350,
			drawIndex: 3,

			damage: 30,
			hitPoints: 3000,
			speed: 50,

			//soundAttacks: "_attacks",
			soundDamage: "beholder_damage",
			soundDies: "beholder_dies",
			
			// Clay.io
			achievementId: "defeatbeholder",
			deathsForAchievement: 1,

			collidable: false,

			lootTable: [
				{type: "item_weapon_fire_sword", weight: 1}
			],

			onInit: function () {
				this.phaseTimer = new horde.Timer();
				this.attackTimer = new horde.Timer();
				this.eyeletOffset = 100;
				this.eyeletOffsetMod = 1;
				this.enraged = false;
			},

			onUpdate: function (elapsed, engine) {

				this.attackTimer.update(elapsed);
				if (this.attackTimer.expired()) {
					horde.sound.play("wizard_attacks");

					var id = engine.spawnObject(this, "e_energy_ball");
					var o = engine.objects[id];
					o.chase(engine.getPlayerObject());
					this.attackTimer.reset();
				}

				this.eyeletOffset += (((20 / 1000) * elapsed) * this.eyeletOffsetMod);
				if (this.eyeletOffset > 120) {
					this.eyeletOffsetMod = -1;
				}
				if (this.eyeletOffset < 100) {
					this.eyeletOffsetMod = 1;
				}

				if (this.wounds > (this.hitPoints / 2) && !this.enraged) {
					this.enraged = true;
					this.speed *= 1.5;
					this.animDelay /= 2;
					this.attackTimer.start(2000);
				}

				switch (this.phase) {

					// Charge out of the gates (invisible)
					case 0:
						if (!this.phaseInit) {
							this.speed = 200;
							this.addState(horde.Object.states.INVISIBLE);
							this.phaseInit = true;
						}
						if (this.position.y >= 70) {
							this.nextPhase();
						}
						break;

					// Phase in
					case 1:
						if (!this.phaseInit) {
							horde.sound.play("wizard_reappear");
							this.speed = 50;
							this.removeState(horde.Object.states.INVISIBLE);
							this.addState(horde.Object.states.INVINCIBLE);
							this.phaseTimer.start(2000);
							this.phaseInit = true;
						}
						movementTypes.wander.apply(this, arguments);
						if (this.phaseTimer.expired()) {
							this.attackTimer.start(4000);
							this.nextPhase();
						}
						break;

					// Wander and spawn X eyelets (now attackable)
					case 2:
						if (!this.phaseInit) {
							this.removeState(horde.Object.states.INVINCIBLE);
							this.collidable = true;
							this.eyeletTimer = new horde.Timer();
							this.eyeletTimer.start(500);
							this.eyeletsSpawned = 0;
							this.phaseInit = true;
						}
						this.eyeletTimer.update(elapsed);
						movementTypes.wander.apply(this, arguments);
						if (this.eyeletTimer.expired()) {
							horde.sound.play("wizard_reappear");

							this.eyeletTimer.reset();
							var id = engine.spawnObject(this, "eyelet");
							if (this.wounds > (this.hitPoints / 2)) {
								var o = engine.objects[id];
								o.makeBadass();
							}
							++this.eyeletsSpawned;
							if (this.eyeletsSpawned >= 12) {
								this.nextPhase();
							}
						}
						break;

					case 3:
						if (!this.phaseInit) {
							this.phaseTimer.start(20000);
							this.phaseInit = true;
						}
						var hasEyelets = false;
						for (var id in engine.objects) {
							if (engine.objects[id].ownerId === this.id) {
								hasEyelets = true;
								break;
							}
						}
						if (this.phaseTimer.expired() || !hasEyelets) {
							this.nextPhase();
						}
						movementTypes.wander.apply(this, arguments);
						break;

					// Shake
					case 4:
						if (!this.phaseInit) {
							this.stopMoving();
							this.phaseTimer.start(2000);
							this.phaseInit = true;
						}
						this.position.x += horde.randomRange(-2, 2);
						if (this.phaseTimer.expired()) {
							this.nextPhase();
						}
						break;
					
					// Shit some gas clouds
					case 5:
						for (var n = 0; n < 2; ++n) {
							engine.spawnObject(this, "gas_cloud");
						}
						this.nextPhase();
						break;

					case 6:
						if (!this.phaseInit) {
							this.oldSpeed = this.speed;
							this.speed = 250;
							this.oldAnimDelay = this.animDelay;
							this.animDelay = 100;
							this.chase(engine.getPlayerObject());
							this.phaseTimer.start(1000); // Must charge for at least 1s
							this.phaseInit = true;
						}
						break;

				}	
			},

			onWallCollide: function () {
				if (this.phase === 6 && this.phaseTimer.expired()) {
					this.speed = this.oldSpeed;
					this.animDelay = this.oldAnimDelay;
					this.setPhase(2);
				}
			}

		};

		o.gas_cloud = {
			role: "trap",
			team: 1,

			animated: true,
			size: new horde.Size(128, 128),
			spriteSheet: "characters",
			spriteX: 640,
			spriteY: 416,
			drawIndex: 2,
			animDelay: 400,

			damage: 20,
			hitPoints: 9999,
			speed: 10,
			ttl: 90000,
			
			damageType: "magic",

			onInit: function () {
				this.setDirection(horde.randomDirection());
				this.moveChangeDelay = horde.randomRange(5000, 10000);
			},

			onUpdate: function (elasped, engine) {
				if (this.animFrameIndex === 2) {
					this.animated = false;
					this.spriteX = 896;
				}
				if (
					this.team === 1
					&& !engine.objects[this.ownerId]
					&& (this.ttl - this.ttlElapsed > 2000)
				) {
					this.ttlElapsed = (this.ttl - 2000);
				}
				movementTypes.wander.apply(this, arguments);
			},

			onObjectCollide: function (object, engine) {
				if (object.team !== this.team && object.role !== "projectile") {
					object.addState(horde.Object.states.SLOWED, 300);
				}
				if (this.team !== 3 && object.damageType == "magic") {
					horde.sound.play("fire_attack");
					this.ownerId = null;
					this.team = 3;
					this.damage = 5;
					this.ttl = 2000;
					this.ttlElapsed = 0;
					this.spriteY += 224;
					this.animDelay = 500;
					this.animFrameIndex = 0;
					this.animNumFrames = 3;
				}
			}

		};

		o.dragon = {
			role: "monster",
			team: 1,
			badass: true,

			animated: true,
			gibletSize: "large",
			size: new horde.Size(64, 64),
			spriteSheet: "characters",
			spriteY: 352,

			moveChangeElapsed: 0,
			moveChangeDelay: 0,

			damage: 20,
			hitPoints: 1000,
			speed: 20,
			worth: 0,

			soundAttacks: "dragon_attacks",
			soundDamage: "dragon_damage",
			soundDies: "dragon_dies",
			
			// Clay.io
			achievementId: "defeatdragon",
			deathsForAchievement: 1,

			weapons: [{type: "e_fireball", count: null}],

			lootTable: [
				{type: "item_gold_chest", weight: 1}
			],

			phase: 0,
			phaseInit: false,

			onInit: function () {
				this.phaseTimer = new horde.Timer();
				this.moveChangeDelay = horde.randomRange(500, 1000);
				this.setDirection(horde.directions.toVector(horde.directions.DOWN));
				this.altTimer = new horde.Timer();
			},
			onUpdate: function (elapsed, engine) {
				
				this.altTimer.update(elapsed);

				switch (this.phase) {
					
					// Charge out of the gates
					case 0:
						if (!this.phaseInit) {
							this.speed = 200;
							this.animDelay = 50;
							this.phaseInit = true;
						}
						if (this.position.y >= 200) {
							this.phase++;
							this.phaseInit = false;
						}
						break;
					
					case 1:
						if (!this.phaseInit) {
							this.stopMoving();
							this.animDelay = 300;
							this.phaseTimer.start(1000);
							this.phaseInit = true;
						}
						this.position.x += horde.randomRange(-1, 1);
						if (this.phaseTimer.expired()) {
							this.nextPhase();
						}
						break;
					
					case 2:
						if (!this.phaseInit) {
							this.cooldown = false;
							this.stopMoving();
							this.weapons = [{type: "e_ring_fire", count: null}];
							this.phaseInit = false;
						}
						engine.objectAttack(this);
						this.nextPhase();
						break;
					
					// Wiggle it!
					case 3:
						if (!this.phaseInit) {
							this.speed = 0;
							this.animDelay = 100;
							this.phaseTimer.start(2000);
							this.phaseInit = true;
							this.altTimer.start(350);
							this.followUpShot = false;
						}
						if (!this.followUpShot && this.altTimer.expired()) {
							if (this.wounds > (this.hitPoints / 2)) {
								this.cooldown = false;
								this.weapons = [{type: "e_ring_fire_dopp", count: null}];
								engine.objectAttack(this);
								this.followUpShot = true;
							}
						}
						if (this.phaseTimer.expired()) {
							this.phase++;
							this.phaseInit = false;
						}
						this.position.x += horde.randomRange(-1, 1);
						break;

					// Charge player
					case 4:
						if (!this.phaseInit) {
							this.speed = 350;
							this.animDelay = 100;
							this.phaseTimer.start(500);
							this.phaseInit = true;
							var p = engine.getPlayerObject();
							this.chase(p);
						}
						if (this.phaseTimer.expired()) {
							this.phase++;
							this.phaseInit = false;
						}
						break;
					
					// Stand still and spew flames!
					case 5:
						if (!this.phaseInit) {
							this.speed = 0;
							this.animDelay = 400;
							this.weapons = [{type: "e_fireball_green", count: null}];
							this.cooldown = false;
							this.cooldownElapsed = 0;
							this.phaseTimer.start(2500);
							this.phaseInit = true;
							this.altTimer.start(750);
						}
						if (this.phaseTimer.expired()) {
							this.phase = 2;
							this.phaseInit = false;
						}
						var p = engine.getPlayerObject();
						this.chase(p);
						if (this.altTimer.expired() && this.wounds > (this.hitPoints / 2)) {
							engine.spawnObject(this, "e_fireball");
							this.altTimer.reset();
							// I don't know why this sound won't play. I give up.
							//horde.sound.play(this.soundAttacks);
						}

						return "shoot";
				}

			}

		};

		// ENEMY WEAPONS

		o.e_arrow = {
			role: "projectile",
			cooldown: 4000,
			speed: 200,
			hitPoints: 1,
			damage: 5,
			spriteSheet: "objects",
			spriteX: 256,
			spriteY: 0,
			spriteAlign: true,
			bounce: false,
			// Clay.io
			ignoreLogDeath: true
		};

		o.e_trident = {
			role: "projectile",
			cooldown: 5000,
			speed: 200,
			hitPoints: 1,
			damage: 10,
			spriteSheet: "objects",
			spriteX: 160,
			spriteY: 0,
			spriteAlign: true,
			bounce: false,
			// Clay.io
			ignoreLogDeath: true
		};

		o.e_boulder = {
			role: "projectile",
			cooldown: 2000,
			speed: 150,
			hitPoints: Infinity,
			damage: 15,
			spriteSheet: "objects",
			spriteX: 224,
			spriteY: 0,
			rotate: true,
			bounce: false,
			// Clay.io
			ignoreLogDeath: true
		};

		o.e_bouncing_boulder = {
			role: "projectile",
			cooldown: 1500,
			speed: 150,
			hitPoints: Infinity,
			damage: 15,
			spriteSheet: "objects",
			spriteX: 224,
			spriteY: 0,
			rotate: true,
			bounce: true,
			ttl: 5000,
			// Clay.io
			ignoreLogDeath: true
		};

		o.e_minotaur_trident = {
			role: "projectile",
			cooldown: 2000,
			speed: 200,
			hitPoints: Infinity,
			damage: 20,
			spriteAlign: true,
			spriteSheet: "objects",
			spriteX: 160,
			spriteY: 0,
			bounce: false,
			// Clay.io
			ignoreLogDeath: true
		};

		o.e_energy_ball = {
			role: "projectile",
			cooldown: 2000,
			speed: 200,
			hitPoints: Infinity,
			damage: 25,
			spriteSheet: "objects",
			spriteX: 320,
			spriteY: 0,
			rotate: true,
			bounce: false,
			// Clay.io
			ignoreLogDeath: true
		};

		o.e_ring_fire = {
			role: "projectile",
			cooldown: 2000,
			speed: 200,
			hitPoints: Infinity,
			damage: 20,
			spriteSheet: "objects",
			spriteX: 352,
			spriteY: 0,
			rotate: true,
			bounce: false,
			damageType: "magic",
			// Clay.io
			ignoreLogDeath: true
		};

		o.e_ring_fire_dopp = {
			role: "projectile",
			cooldown: 2000,
			speed: 150,
			hitPoints: Infinity,
			damage: 25,
			spriteSheet: "objects",
			spriteX: 352,
			spriteY: 544,
			rotate: true,
			bounce: false,
			damageType: "magic",
			// Clay.io
			ignoreLogDeath: true
		};

		o.e_fireball = {
			role: "projectile",
			cooldown: 2000,
			speed: 350,
			hitPoints: Infinity,
			damage: 20,
			spriteSheet: "objects",
			spriteX: 352,
			spriteY: 544,
			rotate: true,
			bounce: false,
			damageType: "magic",
			// Clay.io
			ignoreLogDeath: true
		};

		o.e_fireball_green = {
			role: "projectile",
			cooldown: 75,
			speed: 350,
			hitPoints: Infinity,
			damage: 10,
			spriteSheet: "objects",
			spriteX: 352,
			spriteY: 0,
			rotate: true,
			ttl: 400,
			bounce: false,
			damageType: "magic",
			// Clay.io
			ignoreLogDeath: true
		};

		o.e_static_blue_fire = {
			role: "projectile",
			cooldown: 100,
			speed: 0,
			hitPoints: Infinity,
			damage: 5,
			spriteSheet: "objects",
			spriteX: 288,
			spriteY: 32,
			rotate: true,
			rotateSpeed: 100,
			ttl: 1000,
			bounce: false,
			drawIndex: 0,
			damageType: "magic",
			// Clay.io
			ignoreLogDeath: true
		};

		o.e_dopp_fire = {
			role: "projectile",
			cooldown: 200,
			speed: 0,
			hitPoints: Infinity,
			damage: 10,
			spriteSheet: "objects",
			spriteX: 288,
			spriteY: 32,
			rotate: true,
			rotateSpeed: 200,
			ttl: 250,
			bounce: false,
			drawIndex: 0,
			damageType: "magic",
			// Clay.io
			ignoreLogDeath: true
		};

		o.e_static_green_fire = {
			role: "projectile",
			cooldown: 200,
			speed: 0,
			hitPoints: Infinity,
			damage: 10,
			size: new horde.Size(64, 64),
			spriteSheet: "objects",
			spriteX: 64,
			spriteY: 192,
			rotate: true,
			rotateSpeed: 150,
			ttl: 2000,
			bounce: false,
			drawIndex: 0,
			damageType: "magic",
			// Clay.io
			ignoreLogDeath: true
		};

		o.e_dirt_pile = {
			role: "trap",
			cooldown: 100,
			speed: 0,
			hitPoints: Infinity,
			damage: 0,
			spriteSheet: "characters",
			spriteX: 0,
			spriteY: 448,
			//animated: true,
			ttl: 3000,
			bounce: false,
			drawIndex: -2,
			
			onInit: function () {
				if (horde.randomRange(1, 10) > 5) {
					this.spriteX += 32;
				}
			},
			
			onObjectCollide: function (object, engine) {
				if (object.team !== this.team && object.role !== "projectile") {
					object.addState(horde.Object.states.SLOWED, 300);
				}
			},
			// Clay.io
			ignoreLogDeath: true
			
		};

		o.e_spit_pool = {
			role: "trap",
			cooldown: 100,
			speed: 0,
			hitPoints: 9999,
			damage: 5,
			size: new horde.Size(64, 64),
			spriteSheet: "characters",
			spriteX: 896,
			spriteY: 416,
			animated: true,
			ttl: 7500,
			bounce: false,
			drawIndex: -1,
			collidable: false,
			
			onObjectCollide: function (object, engine) {
				if (object.team !== this.team && object.role !== "projectile") {
					object.addState(horde.Object.states.SLOWED, 300);
				}
			},
			// Clay.io
			ignoreLogDeath: true
			
		};

		o.e_shock_wave = {
			role: "projectile",
			cooldown: 1000,
			speed: 200,
			hitPoints: Infinity,
			damage: 10,
			spriteSheet: "objects",
			spriteX: 224,
			spriteY: 32,
			spriteAlign: true,
			bounce: false,
			animated: true,
			damageType: "magic",
			// Clay.io
			ignoreLogDeath: true
		};

		o.e_worm_spit = {
			role: "projectile",
			cooldown: 1000,
			speed: 200,
			hitPoints: 1,
			damage: 10,
			spriteSheet: "objects",
			spriteX: 128,
			spriteY: 64,
			spriteAlign: true,
			bounce: false,
			animated: true,
			damageType: "magic",

			onInit: function () {
				this.dieTimer = new horde.Timer();
				this.dieTimer.start(1000);
			},
			
			onUpdate: function (elapsed, engine) {
				this.dieTimer.update(elapsed);
				if (this.dieTimer.expired()) {
					this.die();
				}
			},
			
			onDelete: function (engine) {
				engine.spawnObject(this, "e_spit_pool");
			},
			// Clay.io
			ignoreLogDeath: true
			
		};

		// OTHER SHIT

		o.mini_heart = {
			role: "fluff",
			spriteSheet: "objects",
			spriteX: 288,
			spriteY: 128,
			size: new horde.Size(10, 10),
			ttl: 600,
			speed: 75,
			collidable: false,
			drawIndex: 5,
			onInit: function () {
				this.setDirection(new horde.Vector2(0, -1));
				this.speed = horde.randomRange(55, 85);
			}
		};

		o.mini_skull = {
			role: "fluff",
			spriteSheet: "objects",
			spriteX: 288 + 32,
			spriteY: 128,
			size: new horde.Size(10, 10),
			ttl: 1300,
			collidable: false,
			drawIndex: 5,
			onInit: function () {
				this.setDirection(new horde.Vector2(0, -1));
				this.speed = horde.randomRange(25, 60);
			}
		};

		o.rose = {
			
			role: "fluff",
			spriteSheet: "objects",
			collidable: false,
			rotate: true,
			
			spriteX: 192,
			spriteY: 256,
			
			drawIndex: -1,
			
			onInit: function () {
				this.speed = horde.randomRange(150, 200);
				this.rotateSpeed = horde.randomRange(75, 100);
				this.phaseTimer = new horde.Timer();
			},
			
			onUpdate: function (elapsed, engine) {
				
				switch (this.phase) {
					
					case 0:
						if (!this.phaseInit) {
							this.phaseInit = true;
							var rnd = horde.randomRange(0, 5);
							this.direction.y = -(rnd / 10);
							this.phaseTimer.start(horde.randomRange(500, 1750));
						}
						this.direction.y += 0.01;
						if (this.phaseTimer.expired()) {
							this.nextPhase();
						}
						break;
					
					case 1:
						if (!this.phaseInit) {
							this.stopMoving();
							this.rotate = false;
							this.phaseInit = true;
						}
						break;
					
				}
				
			}
			
		};

		o.cloud = {
			
			role: "fluff",
			spriteSheet: "objects",
			collidable: false,
			
			drawIndex: 10,
			
			onInit: function () {
				
				this.alpha = 0.25;
				this.speed = horde.randomRange(5, 25);
				this.size = new horde.Size(192, 128);
				
				switch (horde.randomRange(1, 4)) {
					
					case 1:
						this.spriteX = 0;
						this.spriteY = 288;
						break;

					case 2:
						this.size = new horde.Size(128, 96);
						this.spriteX = 192;
						this.spriteY = 288;
						break;

					case 3:
						this.spriteX = 0;
						this.spriteY = 416;
						break;
						
					case 4:
						this.size = new horde.Size(160, 128);
						this.spriteX = 192;
						this.spriteY = 416;
						break;
				}
				
			}
			
		};

		// GATE

		o.gate = {
			role: "fluff",
			speed: 25,
			spriteSheet: "objects",
			spriteX: 0,
			spriteY: 192,
			size: new horde.Size(64, 64)
		};

		o.pickup_arrow = {
			role: "fluff",
			speed: 0,
			spriteSheet: "objects",
			spriteX: 0,
			spriteY: 608,
			size: new horde.Size(118, 52),
			drawIndex: 9,
			animated: true
		};

		// FOOD (Eat Meat!)

		o.item_food = {
			role: "powerup_food",
			healAmount: 10,
			speed: 0,
			spriteSheet: "objects",
			spriteX: 96,
			spriteY: 32,
			ttl: 8000
		};

		// GOLD (Collect Gold!)

		o.item_coin = {
			role: "powerup_coin",
			coinAmount: 100,
			speed: 0,
			spriteSheet: "objects",
			spriteX: 64,
			spriteY: 32,
			ttl: 5000
		};

		o.item_chest = {
			role: "powerup_coin",
			coinAmount: 500,
			speed: 0,
			spriteSheet: "objects",
			spriteX: 32,
			spriteY: 32,
			ttl: 5000
		};

		o.item_gold_chest = {
			role: "powerup_coin",
			coinAmount: 5000,
			speed: 0,
			spriteSheet: "objects",
			spriteX: 0,
			spriteY: 32
		};

		// WEAPON POWERUPS

		o.item_weapon_knife = {
			role: "powerup_weapon",
			speed: 0,
			spriteSheet: "objects",
			spriteX: 32,
			spriteY: 0,
			ttl: 5000,
			wepType: "h_knife",
			wepCount: 125
		};

		o.item_weapon_spear = {
			role: "powerup_weapon",
			speed: 0,
			spriteSheet: "objects",
			spriteX: 96,
			spriteY: 0,
			ttl: 5000,
			wepType: "h_spear",
			wepCount: 100
		};

		o.item_weapon_fireball = {
			role: "powerup_weapon",
			speed: 0,
			spriteSheet: "objects",
			spriteX: 192,
			spriteY: 0,
			ttl: 5000,
			wepType: "h_fireball",
			wepCount: 100
		};

		/*
		o.item_weapon_bomb = {
			role: "powerup_weapon",
			speed: 0,
			spriteSheet: "objects",
			spriteX: 128,
			spriteY: 0,
			ttl: 5000,
			wepType: "h_bomb",
			wepCount: 10
		};
		*/

		o.item_weapon_axe = {
			role: "powerup_weapon",
			speed: 0,
			spriteSheet: "objects",
			spriteX: 192,
			spriteY: 32,
			ttl: 5000,
			wepType: "h_axe",
			wepCount: 75
		};

		o.item_weapon_fire_sword = {
			role: "powerup_weapon",
			speed: 0,
			spriteSheet: "objects",
			spriteX: 384,
			spriteY: 0,
			wepType: "h_fire_sword",
			wepCount: 5000
		};

		/*
		o.item_weapon_fire_knife = {
			role: "powerup_weapon",
			speed: 0,
			spriteSheet: "objects",
			spriteX: 384,
			spriteY: 0,
			ttl: 5000,
			wepType: "h_fire_knife",
			wepCount: 1000
		};
		*/

		}());


		(function define_horde_ImageLoader () {

			horde.ImageLoader = function horde_ImageLoader () {
				this.images = {};
				this.numLoaded = 0;
				this.numImages = 0;
			};
				
			var proto = horde.ImageLoader.prototype;

			proto.load = function horde_Loader_proto_loadImages (images, fn, context) {
				this.callback = function horde_Loader_proto_loadImages_anon () {
					fn.call(context);
				};
				for (var key in images) {
					this.numImages++;
					this.images[key] = new Image();
					horde.on("load", this.handleImageLoad, this.images[key], this);
					horde.on("error", this.handleImageError, this.images[key], this);
					this.images[key].src = images[key];
				}
			};

			proto.increment = function horde_ImageLoader_proto_increment () {
				this.numLoaded++;
				if (this.numLoaded >= this.numImages) {
					this.callback();
				}
			};

			proto.handleImageLoad = function horde_ImageLoader_proto_handleImageLoad (e) {
				this.increment();
			};

			proto.handleImageError = function horde_ImageLoader_proto_handleImageError (e) {
				this.increment();
			};

			proto.getImage = function horde_ImageLoader_proto_getImage (key) {
				if (this.images[key]) {
					return this.images[key];
				}
				return false;
			};

			}());

		(function define_horde_SpawnPoint () {

			/**
			 * Spawn Point object; holds a queue of objects and spawns them at various intervals
			 * @param {number} left Left coordinate of the spawn location
			 * @param {number} top Top coordinate of the spawn location
			 * @param {number} width Width of the spawn location
			 * @param {number} height Height of the spawn location
			 * @constructor
			 */
			horde.SpawnPoint = function horde_SpawnPoint (left, top, width, height) {
				this.delay = 500; // Default delay between spawns
				this.lastSpawnElapsed = 0; // Milliseconds since last spawn
				this.location = new horde.Rect(left, top, width, height); // Spawn point location
				this.queue = []; // Queue of things to spawn
			};

			var proto = horde.SpawnPoint.prototype;

			/**
			 * Updates this spawn point
			 * @param {number} elapsed Elapsed time in milliseconds since last update
			 * @return {mixed} Returns an object to spawn if necessary otherwise false
			 */
			proto.update = function horde_SpawnPoint_proto_update (elapsed, force) {
				this.lastSpawnElapsed += elapsed;
				if (this.lastSpawnElapsed >= this.delay || force === true) {
					this.lastSpawnElapsed = 0;
					if (this.queue.length < 1) {
						return false;
					}
					var type = this.queue.shift();
					var loc = this.location
					var o = horde.makeObject(type);
					o.position.x = horde.randomRange(loc.left, loc.left + loc.width - o.size.width);
					o.position.y = horde.randomRange(loc.top, loc.top + loc.height - o.size.height);
					var d = o.direction.clone();
					d.y = 1;
					o.setDirection(d);
					return o;
				}
				return false;
			};

			/**
			 * Adds a number of a given type of objects to this spawn point's queue
			 * @param {string} type Type of object to spawn
			 * @param {number} count Number of this type to add
			 * @return {void}
			 */
			proto.queueSpawn = function horde_SpawnPoint_proto_queueSpawn (type, count) {
				count = Number(count) || 1;
				for (var i = 0; i < count; i++) {
					this.queue.push(type);
				}
			};

			}());

		(function define_horde_SpawnWave () {

			horde.SpawnWave = function horde_SpawnWave () {
				this.points = [];
				this.nextWaveTime = 20000; // 20 seconds
				this.bossWave = false;
			};

			var proto = horde.SpawnWave.prototype;

			proto.addSpawnPoint = function horde_SpawnWave_proto_addSpawnPoint (index, spawnDelay) {
				this.points.push({
					spawnPointId: index,
					delay: spawnDelay,
					objects: []
				});
			};

			proto.addObjects = function horde_SpawnWave_proto_addObjects (id, objType, objCount) {
				var pt = null;
				for (var x in this.points) {
					if (this.points[x].spawnPointId === id) {
						pt = this.points[x];
					}
				}
				if (pt === null) {
					return false;
				}
				pt.objects.push({
					type: objType,
					count: Math.floor(objCount)
				});
			};

			}());

		(function () {
			var e = new horde.Engine();
			e.run();
		}());
	</script>

</body>
</html>
